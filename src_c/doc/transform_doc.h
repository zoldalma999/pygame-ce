/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_TRANSFORM "pygame.transform\n\n\n\nPygame module to transform surfaces.\n\nA Surface transform is an operation that moves or resizes the pixels. All these\nfunctions take a Surface to operate on and return a new Surface with the\nresults.\n\nSome of the transforms are considered destructive. These means every time they\nare performed they lose pixel data. Common examples of this are resizing and\nrotating. For this reason, it is better to re-transform the original surface\nthan to keep transforming an image multiple times. (For example, suppose you\nare animating a bouncing spring which expands and contracts. If you applied the\nsize changes incrementally to the previous images, you would lose detail.\nInstead, always begin with the original image and scale to the desired size.)\n\nChanged in pygame 2.0.2: transform functions now support keyword arguments."
#define DOC_TRANSFORM_FLIP "pygame.transform.flip()\n\nFlip vertically and horizontally.\n\nflip(surface, flip_x, flip_y) -> Surface\n\nThis can flip a Surface either vertically, horizontally, or both.\nThe arguments flip_x and flip_y are booleans that control whether\nto flip each axis. Flipping a Surface is non-destructive and returns a new\nSurface with the same dimensions."
#define DOC_TRANSFORM_SCALE "pygame.transform.scale()\n\nResize to new resolution.\n\nscale(surface, size, dest_surface=None) -> Surface\n\nResizes the Surface to a new size, given as (width, height).\nThis is a fast scale operation that does not sample the results.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must be the same as the size (width, height) passed\nin, and the same depth and format as the source Surface.\n\nChanged in pygame-ce 2.2.1: internal scaling algorithm was replaced with a nearly\nequivalent one that is 40% faster. Scale results will be very slightly\ndifferent."
#define DOC_TRANSFORM_SCALEBY "pygame.transform.scale_by()\n\nResize to new resolution, using scalar(s).\n\nscale_by(surface, factor, dest_surface=None) -> Surface\n\nSame as scale(), but scales by some factor, rather than taking\nthe new size explicitly. For example, transform.scale_by(surf, 3)\nwill triple the size of the surface in both dimensions. Optionally, the\nscale factor can be a sequence of two numbers, controlling x and y scaling\nseparately. For example, transform.scale_by(surf, (2, 1)) doubles\nthe image width but keeps the height the same.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the scaled dimensions\n(width * factor, height * factor) and same depth and format as the source Surface.\n\nNew in pygame-ce 2.1.3."
#define DOC_TRANSFORM_ROTATE "pygame.transform.rotate()\n\nRotate an image.\n\nrotate(surface, angle) -> Surface\n\nUnfiltered counterclockwise rotation. The angle argument represents degrees\nand can be any floating point value. Negative angle amounts will rotate\nclockwise.\n\nUnless rotating by 90 degree increments, the image will be padded larger to\nhold the new size. If the image has pixel alphas, the padded area will be\ntransparent. Otherwise pygame will pick a color that matches the Surface\ncolorkey or the topleft pixel value."
#define DOC_TRANSFORM_ROTOZOOM "pygame.transform.rotozoom()\n\nFiltered scale and rotation.\n\nrotozoom(surface, angle, scale) -> Surface\n\nThis is a combined scale and rotation transform. The resulting Surface will\nbe a filtered 32-bit Surface. The scale argument is a floating point value\nthat will be multiplied by the current resolution. The angle argument is a\nfloating point value that represents the counterclockwise degrees to rotate.\nA negative rotation angle will rotate clockwise."
#define DOC_TRANSFORM_SCALE2X "pygame.transform.scale2x()\n\nSpecialized image doubler.\n\nscale2x(surface, dest_surface=None) -> Surface\n\nThis will return a new image that is double the size of the original. It\nuses the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of\nbitmap graphics.\n\nThis really only has an effect on simple images with solid colors. On\nphotographic and antialiased images it will look like a regular unfiltered\nscale.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have double the dimensions\n(width * 2, height * 2) and same depth and format as the source Surface."
#define DOC_TRANSFORM_SMOOTHSCALE "pygame.transform.smoothscale()\n\nScale a surface to an arbitrary size smoothly.\n\nsmoothscale(surface, size, dest_surface=None) -> Surface\n\nUses one of two different algorithms for scaling each dimension of the input\nsurface as required. For shrinkage, the output pixels are area averages of\nthe colors they cover. The size is a 2 number sequence for (width, height).\nThis function only works for 24-bit or 32-bit surfaces. A ValueError will\nbe thrown if the input surface bit depth is less than 24.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must be the same as the size (width, height) passed\nin, and the same depth and format as the source Surface.\n\nNew in pygame 1.8.\n\nChanged in pygame-ce 2.4.0: now uses SSE2/NEON SIMD for acceleration on x86\nand ARM machines, a performance improvement over previous MMX/SSE only\nsupported on x86."
#define DOC_TRANSFORM_SMOOTHSCALEBY "pygame.transform.smoothscale_by()\n\nResize to new resolution, using scalar(s).\n\nsmoothscale_by(surface, factor, dest_surface=None) -> Surface\n\nSame as smoothscale(), but scales by some factor, rather than\ntaking the new size explicitly. For example,\ntransform.smoothscale_by(surf, 3) will triple the size of the\nsurface in both dimensions. Optionally, the scale factor can be a sequence\nof two numbers, controlling x and y scaling separately. For example,\ntransform.smoothscale_by(surf, (2, 1)) doubles the image width but\nkeeps the height the same.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the scaled dimensions\n(width * factor, height * factor) and same depth and format as the source Surface.\n\nNew in pygame-ce 2.1.3."
#define DOC_TRANSFORM_GETSMOOTHSCALEBACKEND "pygame.transform.get_smoothscale_backend()\n\nReturn smoothscale filter version in use: 'GENERIC', 'MMX', 'SSE', 'SSE2', or 'NEON'.\n\nget_smoothscale_backend() -> Literal['GENERIC', 'SSE2', 'NEON']\n\nShows whether or not smoothscale is using SIMD acceleration.\nIf no acceleration is available then \"GENERIC\" is returned. The level of\nacceleration possible is automatically determined at runtime.\n\nThis function is provided for pygame testing and debugging.\n\nChanged in pygame-ce 2.4.0: Added SSE2 and NEON backends, MMX and SSE are deprecated."
#define DOC_TRANSFORM_SETSMOOTHSCALEBACKEND "pygame.transform.set_smoothscale_backend()\n\nSet smoothscale filter version to one of: 'GENERIC', 'MMX', 'SSE', 'SSE2', or 'NEON'.\n\nset_smoothscale_backend(backend) -> None\n\nSets smoothscale acceleration. Takes a string argument. A value of 'GENERIC'\nturns off acceleration. A value error is raised if type is not\nrecognized or not supported by the current processor.\n\nThis function is provided for pygame testing and debugging. If smoothscale\ncauses an invalid instruction error then it is a pygame/SDL bug that should\nbe reported. Use this function as a temporary fix only.\n\nChanged in pygame-ce 2.4.0: Added SSE2 and NEON backends, MMX and SSE are deprecated."
#define DOC_TRANSFORM_CHOP "pygame.transform.chop()\n\nGets a copy of an image with an interior area removed.\n\nchop(surface, rect) -> Surface\n\nExtracts a portion of an image. All vertical and horizontal pixels\nsurrounding the given rectangle area are removed. The corner areas (diagonal\nto the rect) are then brought together. (The original image is not altered\nby this operation.)\n\nNOTE: If you want a \"crop\" that returns the part of an image within a\nrect, you can blit with a rect to a new surface or copy a subsurface."
#define DOC_TRANSFORM_LAPLACIAN "pygame.transform.laplacian()\n\nFind edges in a surface.\n\nlaplacian(surface, dest_surface=None) -> Surface\n\nFinds the edges in a surface using the laplacian algorithm.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth as the source Surface.\n\nNew in pygame 1.8."
#define DOC_TRANSFORM_BOXBLUR "pygame.transform.box_blur()\n\nBlur a surface using box blur.\n\nbox_blur(surface, radius, repeat_edge_pixels=True, dest_surface=None) -> Surface\n\nReturns the blurred surface using box blur algorithm.\n\nThis function does not work for indexed surfaces.\nAn exception will be thrown if the input is an indexed surface.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth and format as the source Surface.\n\nNew in pygame-ce 2.2.0.\n\nChanged in pygame-ce 2.3.0: Passing the calling surface as destination surface raises a ValueError\n\nChanged in pygame-ce 2.5.0: A surface with either width or height equal to 0 won't raise a ValueError"
#define DOC_TRANSFORM_GAUSSIANBLUR "pygame.transform.gaussian_blur()\n\nBlur a surface using gaussian blur.\n\ngaussian_blur(surface, radius, repeat_edge_pixels=True, dest_surface=None) -> Surface\n\nReturns the blurred surface using gaussian blur algorithm.\nSlower than box_blur().\n\nThis function does not work for indexed surfaces.\nAn exception will be thrown if the input is an indexed surface.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth and format as the source Surface.\n\nNew in pygame-ce 2.2.0.\n\nChanged in pygame-ce 2.3.0: Passing the calling surface as destination surface raises a ValueError\n\nChanged in pygame-ce 2.3.1: Now the standard deviation of the Gaussian kernel is equal to the radius.\nBlur results will be slightly different.\n\nChanged in pygame-ce 2.5.0: A surface with either width or height equal to 0 won't raise a ValueError"
#define DOC_TRANSFORM_AVERAGESURFACES "pygame.transform.average_surfaces()\n\nFind the average surface from many surfaces.\n\naverage_surfaces(surfaces, dest_surface=None, palette_colors=1) -> Surface\n\nTakes a sequence of surfaces and returns a surface with average colors from\neach of the surfaces.\n\npalette_colors - if true we average the colors in palette, otherwise we\naverage the pixel values. This is useful if the surface is actually\ngrayscale colors, and not palette colors.\n\nNote, this function currently does not handle palette using surfaces\ncorrectly.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth as the first passed source Surface.\n\nNew in pygame 1.8.\n\nNew in pygame 1.9: palette_colors argument"
#define DOC_TRANSFORM_AVERAGECOLOR "pygame.transform.average_color()\n\nFinds the average color of a surface.\n\naverage_color(surface, rect=None, consider_alpha=False) -> tuple[int, int, int, int]\n\nFinds the average color of a Surface or a region of a surface specified by a\nRect, and returns it as a tuple of integers red, green, blue, and alpha.\nIf consider_alpha is set to True, then alpha is taken into account\n(removing the black artifacts).\n\nNew in pygame 2.1.2: consider_alpha argument"
#define DOC_TRANSFORM_INVERT "pygame.transform.invert()\n\nInverts the RGB elements of a surface.\n\ninvert(surface, dest_surface=None) -> Surface\n\nInverts each RGB pixel contained within the Surface, does not affect alpha channel.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth as the source Surface.\n\nNew in pygame-ce 2.2.0."
#define DOC_TRANSFORM_GRAYSCALE "pygame.transform.grayscale()\n\nGrayscale a surface.\n\ngrayscale(surface, dest_surface=None) -> Surface\n\nReturns a grayscaled version of the original surface using the luminosity formula which weights red, green and blue according to their wavelengths.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface. This destination surface must have the same dimensions (width, height) and\ndepth as the source Surface.\n\nNew in pygame-ce 2.1.4.\n\nChanged in pygame-ce 2.4.0: Adjusted formula slightly to support performance\noptimisation. It may return very slightly different pixels than before,\nbut should run seven to eleven times faster on most systems."
#define DOC_TRANSFORM_SOLIDOVERLAY "pygame.transform.solid_overlay()\n\nReplaces non transparent pixels with the provided color.\n\nsolid_overlay(surface, color, dest_surface=None, keep_alpha=False) -> Surface\n\nReturns a new version of the original surface with all non transparent pixels set to the color provided.\n\nAn optional destination surface can be passed which is faster than creating a new\nSurface.\nThis destination surface must have the same dimensions (width, height) and\ndepth as the source Surface.\n\nParameters\n\nsurface (pygame.Surface) -- The target surface.\n\ncolor (pygame.typing.ColorLike) -- Color which all non transparent within the target surface must be set to.\n\ndest_surface (pygame.Surface or None) -- Optional destination surface to which the changes will be applied.\n\nkeep_alpha (bool) -- Optional parameter that controls whether to keep the surface alpha when replacing with the color.\n\nNew in pygame-ce 2.5.2."
#define DOC_TRANSFORM_THRESHOLD "pygame.transform.threshold()\n\nFinds which, and how many pixels in a surface are within a threshold of a 'search_color' or a 'search_surf'.\n\nthreshold(dest_surface, surface, search_color, threshold=(0, 0, 0, 0), set_color=(0, 0, 0, 0), set_behavior=1, search_surf=None, inverse_set=False) -> int\n\nThis versatile function can be used for find colors in a 'surf' close to a 'search_color'\nor close to colors in a separate 'search_surf'.\n\nIt can also be used to transfer pixels into a 'dest_surf' that match or don't match.\n\nBy default it sets pixels in the 'dest_surf' where all of the pixels NOT within the\nthreshold are changed to set_color. If inverse_set is optionally set to True,\nthe pixels that ARE within the threshold are changed to set_color.\n\nIf the optional 'search_surf' surface is given, it is used to threshold against\nrather than the specified 'set_color'. That is, it will find each pixel in the\n'surf' that is within the 'threshold' of the pixel at the same coordinates\nof the 'search_surf'.\n\nParameters\n\ndest_surf (pygame.Surface or None) -- Surface we are changing. See 'set_behavior'.\nShould be None if counting (set_behavior is 0).\n\nsurf (pygame.Surface) -- Surface we are looking at.\n\nsearch_color -- Color we are searching for.\n\nthreshold -- Within this distance from search_color (or search_surf).\nYou can use a threshold of (r,g,b,a) where the r,g,b can have different\nthresholds. So you could use an r threshold of 40 and a blue threshold of 2\nif you like.\n\nset_color -- Color we set in dest_surf.\n\nset_behavior (int) -- set_behavior=1 (default). Pixels in dest_surface will be changed to 'set_color'.\n\nset_behavior=0 we do not change 'dest_surf', just count. Make dest_surf=None.\n\nset_behavior=2 pixels set in 'dest_surf' will be from 'surf'.\n\nsearch_surf (pygame.Surface or None) -- search_surf=None (default). Search against 'search_color' instead.\n\nsearch_surf=Surface. Look at the color in 'search_surf' rather than using 'search_color'.\n\ninverse_set (bool) -- False, default. Pixels outside of threshold are changed.\n\nTrue, Pixels within threshold are changed.\n\nReturn type\n\nint\n\nReturns\n\nThe number of pixels that are within the 'threshold' in 'surf'\ncompared to either 'search_color' or search_surf.\n\nNew in pygame 1.8.\n\nChanged in pygame 1.9.4: Fixed a lot of bugs and added keyword arguments. Test your code."
#define DOC_TRANSFORM_HSL "pygame.transform.hsl()\n\nChange the hue, saturation, and lightness of a surface.\n\nhsl(surface, hue=0, saturation=0, lightness=0, dest_surface=None) -> Surface\n\nThis function allows you to modify the hue, saturation, and lightness of a given surface.\n\nParameters\n\nsurface (pygame.Surface) -- The surface to transform.\n\nhue (float) -- The amount to change the hue. Positive values rotate the hue clockwise,\nwhile negative values rotate it counterclockwise. Value range: -360 to 360.\n\nsaturation (float) -- The amount to change the saturation. Positive values increase saturation,\nwhile negative values decrease it. Value range: -1 to 1.\n\nlightness (float) -- The amount to change the lightness. Positive values increase lightness,\nwhile negative values decrease it. Value range: -1 to 1.\n\ndest_surface (pygame.Surface) -- An optional destination surface to store the transformed image.\nIf provided, it should have the same dimensions and depth as the source surface.\n\nReturns\n\nA new surface with the hue, saturation, and lightness transformed.\n\nExamples\n\n\n\nApply a hue rotation of 30 degrees, increase saturation by 20%, and decrease lightness by 10% to a surface:\n\nnew_surf = hsl(original_surf, 30, 0.2, -0.1)\n\nNew in pygame-ce 2.5.0."
