/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_SPRITE "pygame.sprite\n\n\n\npygame module with basic game object classes\n\nThis module contains several simple classes to be used within games. There is\nthe main Sprite class and several Group classes that contain Sprites. The use\nof these classes is entirely optional when using pygame. The classes are fairly\nlightweight and only provide a starting place for the code that is common to\nmost games.\n\nThe Sprite class is intended to be used as a base class for the different types\nof objects in the game. There is also a base Group class that simply stores\nsprites. A game could create new types of Group classes that operate on\nspecially customized Sprite instances they contain.\n\nThe basic Group class can draw the Sprites it contains to a Surface. The\nGroup.draw() method requires that each Sprite have a Sprite.image\nattribute and a Sprite.rect. The Group.clear() method requires these\nsame attributes, and can be used to erase all the Sprites with background.\nThere are also more advanced Groups: pygame.sprite.RenderUpdates().\n\nLastly, this module contains several collision functions. These help find\nsprites inside multiple groups that have intersecting bounding rectangles. To\nfind the collisions, the Sprites are required to have a Sprite.rect\nattribute assigned.\n\nThe groups are designed for high efficiency in removing and adding Sprites to\nthem. They also allow cheap testing to see if a Sprite already exists in a\nGroup. A given Sprite can exist in any number of groups. A game could use some\ngroups to control object rendering, and a completely separate set of groups to\ncontrol interaction or player movement. Instead of adding type attributes or\nbools to a derived Sprite class, consider keeping the Sprites inside organized\nGroups. This will allow for easier lookup later in the game.\n\nSprites and Groups manage their relationships with the add() and\nremove() methods. These methods can accept a single or multiple targets for\nmembership. The default initializers for these classes also takes a single or\nlist of targets for initial membership. It is safe to repeatedly add and remove\nthe same Sprite from a Group.\n\nWhile it is possible to design sprite and group classes that don't derive from\nthe Sprite and AbstractGroup classes below, it is strongly recommended that you\nextend those when you add a Sprite or Group class.\n\nSprites are not thread safe. So lock them yourself if using threads."
#define DOC_SPRITE_SPRITE "pygame.sprite.Sprite\n\nSimple base class for visible game objects.\n\nSprite(*groups) -> Sprite\n\nThe base class for visible game objects. Derived classes will want to\noverride the Sprite.update() and assign a Sprite.image and\nSprite.rect attributes. The initializer can accept any number of Group\ninstances to be added to.\n\nWhen subclassing the Sprite, be sure to call the base initializer before\nadding the Sprite to Groups. For example:\n\nclass Block(pygame.sprite.Sprite):\n\n    # Constructor. Pass in the color of the block,\n    # and its x and y position\n    def __init__(self, color, width, height):\n       # Call the parent class (Sprite) constructor\n       pygame.sprite.Sprite.__init__(self)\n\n       # Create an image of the block, and fill it with a color.\n       # This could also be an image loaded from the disk.\n       self.image = pygame.Surface([width, height])\n       self.image.fill(color)\n\n       # Fetch the rectangle object that has the dimensions of the image\n       # Update the position of this object by setting the values of rect.x and rect.y\n       self.rect = self.image.get_rect()\n\n"
#define DOC_SPRITE_SPRITE_UPDATE "update()\n\nmethod to control sprite behavior\n\nupdate(*args, **kwargs) -> None\n\nThe default implementation of this method does nothing; it's just a\nconvenient \"hook\" that you can override. This method is called by\nGroup.update() with whatever arguments you give it.\n\nThere is no need to use this method if not using the convenience method\nby the same name in the Group class."
#define DOC_SPRITE_SPRITE_ADD "add()\n\nadd the sprite to groups\n\nadd(*groups) -> None\n\nAny number of Group instances can be passed as arguments. The Sprite will\nbe added to the Groups it is not already a member of."
#define DOC_SPRITE_SPRITE_REMOVE "remove()\n\nremove the sprite from groups\n\nremove(*groups) -> None\n\nAny number of Group instances can be passed as arguments. The Sprite will\nbe removed from the Groups it is currently a member of."
#define DOC_SPRITE_SPRITE_KILL "kill()\n\nremove the Sprite from all Groups\n\nkill() -> None\n\nThe Sprite is removed from all the Groups that contain it. This won't\nchange anything about the state of the Sprite. It is possible to continue\nto use the Sprite after this method has been called, including adding it\nto Groups."
#define DOC_SPRITE_SPRITE_ALIVE "alive()\n\ndoes the sprite belong to any groups\n\nalive() -> bool\n\nReturns True when the Sprite belongs to one or more Groups."
#define DOC_SPRITE_SPRITE_GROUPS "groups()\n\nlist of Groups that contain this Sprite\n\ngroups() -> group_list\n\nReturn a list of all the Groups that contain this Sprite."
#define DOC_SPRITE_DIRTYSPRITE "pygame.sprite.DirtySprite\n\nA subclass of Sprite with more attributes and features.\n\nDirtySprite(*groups) -> DirtySprite\n\nExtra DirtySprite attributes with their default values:\n\ndirty = 1\n\nif set to 1, it is repainted and then set to 0 again\nif set to 2 then it is always dirty ( repainted each frame,\nflag is not reset)\n0 means that it is not dirty and therefore not repainted again\n\nblendmode = 0\n\nits the special_flags argument of blit, blendmodes\n\nsource_rect = None\n\nsource rect to use, remember that it is relative to\ntopleft (0,0) of self.image\n\nvisible = 1\n\nnormally 1, if set to 0 it will not be repainted\n(you must set it dirty too to be erased from screen)\n\nlayer = 0\n\n(READONLY value, it is read when adding it to the\nLayeredDirty, for details see doc of LayeredDirty)"
#define DOC_SPRITE_GROUP "pygame.sprite.Group\n\nA container class to hold and manage multiple Sprite objects.\n\nGroup(*sprites) -> Group\n\nA simple container for Sprite objects. This class can be inherited to create\ncontainers with more specific behaviors. The constructor takes any number of\nSprite arguments to add to the Group. All sprites in groups are stored in the\norder they were added to the group. The group supports the following\nstandard Python operations:\n\nin      test if a Sprite is contained\nlen     the number of Sprites contained\nbool    test if any Sprites are contained\niter    iterate through all the Sprites\n\n"
#define DOC_SPRITE_GROUP_SPRITES "sprites()\n\nlist of the Sprites this Group contains\n\nsprites() -> sprite_list\n\nReturn a list of all the Sprites this group contains. You can also get an\niterator from the group, but you cannot iterate over a Group while\nmodifying it."
#define DOC_SPRITE_GROUP_COPY "copy()\n\nduplicate the Group\n\ncopy() -> Group\n\nCreates a new Group with all the same Sprites as the original. If you\nhave subclassed Group, the new object will have the same (sub-)class as\nthe original. This only works if the derived class's constructor takes\nthe same arguments as the Group class's."
#define DOC_SPRITE_GROUP_ADD "add()\n\nadd Sprites to this Group\n\nadd(*sprites) -> None\n\nAdd any number of Sprites to this Group. This will only add Sprites that\nare not already members of the Group.\n\nEach sprite argument can also be an iterator containing Sprites."
#define DOC_SPRITE_GROUP_REMOVE "remove()\n\nremove Sprites from the Group\n\nremove(*sprites) -> None\n\nRemove any number of Sprites from the Group. This will only remove\nSprites that are already members of the Group.\n\nEach sprite argument can also be an iterator containing Sprites."
#define DOC_SPRITE_GROUP_HAS "has()\n\ntest if a Group contains Sprites\n\nhas(*sprites) -> bool\n\nReturn True if the Group contains all of the given sprites. This is\nsimilar to using the \"in\" operator on the Group (\"if sprite in group:\n...\"), which tests if a single Sprite belongs to a Group.\n\nEach sprite argument can also be an iterator containing Sprites."
#define DOC_SPRITE_GROUP_UPDATE "update()\n\ncall the update method on contained Sprites\n\nupdate(*args, **kwargs) -> None\n\nCalls the update() method on all Sprites in the Group. The base\nSprite class has an update method that takes any number of arguments and\ndoes nothing. The arguments passed to Group.update() will be passed\nto each Sprite.\n\nThere is no way to get the return value from the Sprite.update()\nmethods."
#define DOC_SPRITE_GROUP_DRAW "draw()\n\nblit the Sprite images\n\ndraw(Surface, bgd=None, special_flags=0) -> list[Rect]\n\nDraws the contained Sprites to the Surface argument. This uses the\nSprite.image attribute for the source surface, and Sprite.rect\nfor the position. special_flags is passed to Surface.blit().\nbgd is unused in this method but LayeredDirty.draw() uses\nit.\n\nThe Group keeps sprites in the order they were added, they will be drawn in this order.\n\nChanged in pygame-ce 2.5.4: Added the bgd and special_flags arguments"
#define DOC_SPRITE_GROUP_CLEAR "clear()\n\ndraw a background over the Sprites\n\nclear(Surface_dest, background) -> None\n\nErases the Sprites used in the last Group.draw() call. The\ndestination Surface is cleared by filling the drawn Sprite positions with\nthe background.\n\nThe background is usually a Surface image the same dimensions as the\ndestination Surface. However, it can also be a callback function that\ntakes two arguments; the destination Surface and an area to clear. The\nbackground callback function will be called several times each clear.\n\nHere is an example callback that will clear the Sprites with solid red:\n\ndef clear_callback(surf, rect):\n    color = 255, 0, 0\n    surf.fill(color, rect)"
#define DOC_SPRITE_GROUP_EMPTY "empty()\n\nremove all Sprites\n\nempty() -> None\n\nRemoves all Sprites from this Group."
#define DOC_SPRITE_RENDERUPDATES "pygame.sprite.RenderUpdates\n\nGroup sub-class that tracks dirty updates.\n\nRenderUpdates(*sprites) -> RenderUpdates\n\nThis class is derived from pygame.sprite.Group(). It has an extended\ndraw() method that tracks the changed areas of the screen.\n\n"
#define DOC_SPRITE_RENDERUPDATES_DRAW "draw()\n\nblit the Sprite images and track changed areas\n\ndraw(surface, bgd=None, special_flags=0) -> Rect_list\n\nDraws all the Sprites to the surface, the same as Group.draw(). This\nmethod also returns a list of Rectangular areas on the screen that have\nbeen changed. The returned changes include areas of the screen that have\nbeen affected by previous Group.clear() calls. special_flags is\npassed to Surface.blit(). bgd is unused in this method but\nLayeredDirty.draw() uses it.\n\nThe returned Rect list should be passed to pygame.display.update().\nThis will help performance on software driven display modes. This type of\nupdating is usually only helpful on destinations with non-animating\nbackgrounds.\n\nChanged in pygame-ce 2.5.4: Added the bgd and special_flags arguments"
#define DOC_SPRITE_LAYEREDUPDATES "pygame.sprite.LayeredUpdates\n\nLayeredUpdates is a sprite group that handles layers and draws like RenderUpdates.\n\nLayeredUpdates(*sprites, **kwargs) -> LayeredUpdates\n\nThis group is fully compatible with pygame.sprite.Sprite.\n\nYou can set the default layer through kwargs using 'default_layer' and an\ninteger for the layer. The default layer is 0.\n\nIf the sprite you add has an attribute _layer then that layer will be used.\nIf the **kwarg contains 'layer' then the sprites passed will be added to\nthat layer (overriding the sprite.layer attribute). If neither sprite\nhas attribute layer nor **kwarg then the default layer is used to add the\nsprites.\n\nNew in pygame 1.8.\n\n"
#define DOC_SPRITE_LAYEREDUPDATES_ADD "add()\n\nadd a sprite or sequence of sprites to a group\n\nadd(*sprites, **kwargs) -> None\n\nIf the sprite(s) have an attribute layer then that is used for the\nlayer. If **kwargs contains 'layer' then the sprite(s) will be added\nto that argument (overriding the sprite layer attribute). If neither is\npassed then the sprite(s) will be added to the default layer."
#define DOC_SPRITE_LAYEREDUPDATES_SPRITES "sprites()\n\nreturns an ordered list of sprites (first back, last top).\n\nsprites() -> sprites"
#define DOC_SPRITE_LAYEREDUPDATES_DRAW "draw()\n\ndraw all sprites in the right order onto the passed surface.\n\ndraw(surface, bgd=None, special_flags=0) -> Rect_list\n\nChanged in pygame-ce 2.5.4: Added the bgd and special_flags arguments"
#define DOC_SPRITE_LAYEREDUPDATES_GETSPRITESAT "get_sprites_at()\n\nreturns a list with all sprites at that position.\n\nget_sprites_at(pos) -> colliding_sprites\n\nBottom sprites first, top last."
#define DOC_SPRITE_LAYEREDUPDATES_GETSPRITE "get_sprite()\n\nreturns the sprite at the index idx from the groups sprites\n\nget_sprite(idx) -> sprite\n\nRaises IndexOutOfBounds if the idx is not within range."
#define DOC_SPRITE_LAYEREDUPDATES_REMOVESPRITESOFLAYER "remove_sprites_of_layer()\n\nremoves all sprites from a layer and returns them as a list.\n\nremove_sprites_of_layer(layer_nr) -> sprites"
#define DOC_SPRITE_LAYEREDUPDATES_LAYERS "layers()\n\nreturns a list of layers defined (unique), sorted from bottom up.\n\nlayers() -> layers"
#define DOC_SPRITE_LAYEREDUPDATES_CHANGELAYER "change_layer()\n\nchanges the layer of the sprite\n\nchange_layer(sprite, new_layer) -> None\n\nsprite must have been added to the renderer. It is not checked."
#define DOC_SPRITE_LAYEREDUPDATES_GETLAYEROFSPRITE "get_layer_of_sprite()\n\nreturns the layer that sprite is currently in.\n\nget_layer_of_sprite(sprite) -> layer\n\nIf the sprite is not found then it will return the default layer."
#define DOC_SPRITE_LAYEREDUPDATES_GETTOPLAYER "get_top_layer()\n\nreturns the top layer\n\nget_top_layer() -> layer"
#define DOC_SPRITE_LAYEREDUPDATES_GETBOTTOMLAYER "get_bottom_layer()\n\nreturns the bottom layer\n\nget_bottom_layer() -> layer"
#define DOC_SPRITE_LAYEREDUPDATES_MOVETOFRONT "move_to_front()\n\nbrings the sprite to front layer\n\nmove_to_front(sprite) -> None\n\nBrings the sprite to front, changing sprite layer to topmost layer (added\nat the end of that layer)."
#define DOC_SPRITE_LAYEREDUPDATES_MOVETOBACK "move_to_back()\n\nmoves the sprite to the bottom layer\n\nmove_to_back(sprite) -> None\n\nMoves the sprite to the bottom layer, moving it behind all other layers\nand adding one additional layer."
#define DOC_SPRITE_LAYEREDUPDATES_GETTOPSPRITE "get_top_sprite()\n\nreturns the topmost sprite\n\nget_top_sprite() -> Sprite"
#define DOC_SPRITE_LAYEREDUPDATES_GETSPRITESFROMLAYER "get_sprites_from_layer()\n\nreturns all sprites from a layer, ordered by how they where added\n\nget_sprites_from_layer(layer) -> sprites\n\nReturns all sprites from a layer, ordered by how they where added. It\nuses linear search and the sprites are not removed from layer."
#define DOC_SPRITE_LAYEREDUPDATES_SWITCHLAYER "switch_layer()\n\nswitches the sprites from layer1 to layer2\n\nswitch_layer(layer1_nr, layer2_nr) -> None\n\nThe layers number must exist, it is not checked."
#define DOC_SPRITE_LAYEREDDIRTY "pygame.sprite.LayeredDirty\n\nLayeredDirty group is for DirtySprite objects.  Subclasses LayeredUpdates.\n\nLayeredDirty(*sprites, **kwargs) -> LayeredDirty\n\nThis group requires pygame.sprite.DirtySprite or any sprite that\nhas the following attributes:\n\nimage, rect, dirty, visible, blendmode (see doc of DirtySprite).\n\nIt uses the dirty flag technique and is therefore faster than the\npygame.sprite.RenderUpdates if you have many static sprites. It\nalso switches automatically between dirty rect update and full screen\ndrawing, so you do not have to worry what would be faster.\n\nSame as for the pygame.sprite.Group. You can specify some\nadditional attributes through kwargs:\n\n_use_update: True/False   default is False\n_default_layer: default layer where sprites without a layer are added.\n_time_threshold: threshold time for switching between dirty rect mode\n    and fullscreen mode, defaults to 1000./80  == 1000./fps\n\nNew in pygame 1.8.\n\n"
#define DOC_SPRITE_LAYEREDDIRTY_DRAW "draw()\n\ndraw all sprites in the right order onto the passed surface.\n\ndraw(surface, bgd=None, special_flags=None) -> Rect_list\n\nYou can pass the background too. If a background is already set, then the\nbgd argument has no effect. special_flags is passed to\nSurface.blit().\n\nChanged in pygame-ce 2.5.4: Added the special_flags argument"
#define DOC_SPRITE_LAYEREDDIRTY_CLEAR "clear()\n\nused to set background\n\nclear(surface, bgd) -> None"
#define DOC_SPRITE_LAYEREDDIRTY_REPAINTRECT "repaint_rect()\n\nrepaints the given area\n\nrepaint_rect(screen_rect) -> None\n\nscreen_rect is in screen coordinates."
#define DOC_SPRITE_LAYEREDDIRTY_SETCLIP "set_clip()\n\nclip the area where to draw. Just pass None (default) to reset the clip\n\nset_clip(screen_rect=None) -> None"
#define DOC_SPRITE_LAYEREDDIRTY_GETCLIP "get_clip()\n\nclip the area where to draw. Just pass None (default) to reset the clip\n\nget_clip() -> Rect"
#define DOC_SPRITE_LAYEREDDIRTY_CHANGELAYER "change_layer()\n\nchanges the layer of the sprite\n\nchange_layer(sprite, new_layer) -> None\n\nsprite must have been added to the renderer. It is not checked."
#define DOC_SPRITE_LAYEREDDIRTY_SETTIMINGTRESHOLD "set_timing_treshold()\n\nsets the threshold in milliseconds\n\nset_timing_treshold(time_ms) -> None\n\nDEPRECATED: Use set_timing_threshold() instead.\n\nDeprecated since pygame 2.1.1."
#define DOC_SPRITE_LAYEREDDIRTY_SETTIMINGTHRESHOLD "set_timing_threshold()\n\nsets the threshold in milliseconds\n\nset_timing_threshold(time_ms) -> None\n\nDefaults to 1000.0 / 80.0. This means that the screen will be painted\nusing the flip method rather than the update method if the update\nmethod is taking so long to update the screen that the frame rate falls\nbelow 80 frames per second.\n\nNew in pygame 2.1.1.\n\nRaises\n\nTypeError -- if time_ms is not int or float"
#define DOC_SPRITE_GROUPSINGLE "pygame.sprite.GroupSingle()\n\nGroup container that holds a single sprite.\n\nGroupSingle(sprite=None) -> GroupSingle\n\nThe GroupSingle container only holds a single Sprite. When a new Sprite is\nadded, the old one is removed.\n\nThere is a special property, GroupSingle.sprite, that accesses the\nSprite that this Group contains. It can be None when the Group is empty. The\nproperty can also be assigned to add a Sprite into the GroupSingle\ncontainer."
#define DOC_SPRITE_SPRITECOLLIDE "pygame.sprite.spritecollide()\n\nFind sprites in a group that intersect another sprite.\n\nspritecollide(sprite, group, dokill, collided = None) -> Sprite_list\n\nReturn a list containing all Sprites in a Group that intersect with another\nSprite. Intersection is determined by comparing the Sprite.rect\nattribute of each Sprite.\n\nThe dokill argument is a bool. If set to True, all Sprites that collide will\nbe removed from the Group.\n\nThe collided argument is a callback function used to calculate if two\nsprites are colliding. it should take two sprites as values, and return a\nbool value indicating if they are colliding. If collided is not passed, all\nsprites must have a \"rect\" value, which is a rectangle of the sprite area,\nwhich will be used to calculate the collision.\n\ncollided callables:\n\ncollide_rect, collide_rect_ratio, collide_circle,\ncollide_circle_ratio, collide_mask\n\nExample:\n\n# See if the Sprite block has collided with anything in the Group block_list\n# The True flag will remove the sprite in block_list\nblocks_hit_list = pygame.sprite.spritecollide(player, block_list, True)\n\n# Check the list of colliding sprites, and add one to the score for each one\nfor block in blocks_hit_list:\n    score +=1"
#define DOC_SPRITE_COLLIDERECT "pygame.sprite.collide_rect()\n\nCollision detection between two sprites, using rects.\n\ncollide_rect(left, right) -> bool\n\nTests for collision between two sprites. Uses the pygame rect colliderect\nfunction to calculate the collision. Intended to be passed as a collided\ncallback function to the *collide functions. Sprites must have a \"rect\"\nattributes.\n\nNew in pygame 1.8."
#define DOC_SPRITE_COLLIDERECTRATIO "pygame.sprite.collide_rect_ratio()\n\nCollision detection between two sprites, using rects scaled to a ratio.\n\ncollide_rect_ratio(ratio) -> collided_callable\n\nA callable class that checks for collisions between two sprites, using a\nscaled version of the sprites rects.\n\nIs created with a ratio, the instance is then intended to be passed as a\ncollided callback function to the *collide functions.\n\nA ratio is a floating point number - 1.0 is the same size, 2.0 is twice as\nbig, and 0.5 is half the size.\n\nNew in pygame 1.8.1."
#define DOC_SPRITE_COLLIDECIRCLE "pygame.sprite.collide_circle()\n\nCollision detection between two sprites, using circles.\n\ncollide_circle(left, right) -> bool\n\nTests for collision between two sprites, by testing to see if two circles\ncentered on the sprites overlap. If the sprites have a \"radius\" attribute,\nthat is used to create the circle, otherwise a circle is created that is big\nenough to completely enclose the sprites rect as given by the \"rect\"\nattribute. Intended to be passed as a collided callback function to the\n*collide functions. Sprites must have a \"rect\" and an optional \"radius\"\nattribute.\n\nNew in pygame 1.8.1."
#define DOC_SPRITE_COLLIDECIRCLERATIO "pygame.sprite.collide_circle_ratio()\n\nCollision detection between two sprites, using circles scaled to a ratio.\n\ncollide_circle_ratio(ratio) -> collided_callable\n\nA callable class that checks for collisions between two sprites, using a\nscaled version of the sprites radius.\n\nIs created with a floating point ratio, the instance is then intended to be\npassed as a collided callback function to the *collide functions.\n\nA ratio is a floating point number - 1.0 is the same size, 2.0 is twice as\nbig, and 0.5 is half the size.\n\nThe created callable tests for collision between two sprites, by testing to\nsee if two circles centered on the sprites overlap, after scaling the\ncircles radius by the stored ratio. If the sprites have a \"radius\"\nattribute, that is used to create the circle, otherwise a circle is created\nthat is big enough to completely enclose the sprites rect as given by the\n\"rect\" attribute. Intended to be passed as a collided callback function to\nthe *collide functions. Sprites must have a \"rect\" and an optional \"radius\"\nattribute.\n\nNew in pygame 1.8.1."
#define DOC_SPRITE_COLLIDEMASK "pygame.sprite.collide_mask()\n\nCollision detection between two sprites, using masks.\n\ncollide_mask(sprite1, sprite2) -> (int, int)\n\ncollide_mask(sprite1, sprite2) -> None\n\nTests for collision between two sprites, by testing if their bitmasks\noverlap (uses pygame.mask.Mask.overlap()). If the sprites have a\nmask attribute, it is used as the mask, otherwise a mask is created from\nthe sprite's image (uses pygame.mask.from_surface()). Sprites must\nhave a rect attribute; the mask attribute is optional.\n\nThe first point of collision between the masks is returned. The collision\npoint is offset from sprite1's mask's topleft corner (which is always\n(0, 0)). The collision point is a position within the mask and is not\nrelated to the actual screen position of sprite1.\n\nThis function is intended to be passed as a collided callback function\nto the group collide functions (see spritecollide(),\ngroupcollide(), spritecollideany()).\n\nTo increase performance, create and set a mask attribute for all\nsprites that will use this function to check for collisions. Otherwise,\neach time this function is called it will create new masks.\n\nA new mask needs to be recreated each time a sprite's image is changed\n(e.g. if a new image is used or the existing image is rotated).\n\n# Example of mask creation for a sprite.\nsprite.mask = pygame.mask.from_surface(sprite.image)\n\nReturns\n\nfirst point of collision between the masks or None if no\ncollision\n\nReturn type\n\ntuple(int, int) or NoneType\n\nNew in pygame 1.8.0."
#define DOC_SPRITE_GROUPCOLLIDE "pygame.sprite.groupcollide()\n\nFind all sprites that collide between two groups.\n\ngroupcollide(group1, group2, dokill1, dokill2, collided = None) -> Sprite_dict\n\nThis will find collisions between all the Sprites in two groups.\nCollision is determined by comparing the Sprite.rect attribute of\neach Sprite or by using the collided function if it is not None.\n\nEvery Sprite inside group1 is added to the return dictionary. The value for\neach item is the list of Sprites in group2 that intersect.\n\nIf either dokill argument is True, the colliding Sprites will be removed\nfrom their respective Group.\n\nThe collided argument is a callback function used to calculate if two sprites are\ncolliding. It should take two sprites as values and return a bool value\nindicating if they are colliding. If collided is not passed, then all\nsprites must have a \"rect\" value, which is a rectangle of the sprite area,\nwhich will be used to calculate the collision."
#define DOC_SPRITE_SPRITECOLLIDEANY "pygame.sprite.spritecollideany()\n\nSimple test if a sprite intersects anything in a group.\n\nspritecollideany(sprite, group, collided = None) -> Sprite Collision with the returned sprite.\n\nspritecollideany(sprite, group, collided = None) -> None No collision\n\nIf the sprite collides with any single sprite in the group, a single\nsprite from the group is returned.  On no collision None is returned.\n\nIf you don't need all the features of the pygame.sprite.spritecollide() function, this\nfunction will be a bit quicker.\n\nThe collided argument is a callback function used to calculate if two sprites are\ncolliding. It should take two sprites as values and return a bool value\nindicating if they are colliding. If collided is not passed, then all\nsprites must have a \"rect\" value, which is a rectangle of the sprite area,\nwhich will be used to calculate the collision."
