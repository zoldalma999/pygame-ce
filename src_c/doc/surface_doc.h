/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_SURFACE "pygame.Surface\n\nPygame object for representing images.\n\nSurface(size, flags=0, depth=0, masks=None) -> Surface\n\nSurface(size, flags=0, surface=...) -> Surface\n\nA pygame Surface is used to represent any image. The Surface has a fixed\nresolution and pixel format. Surfaces with 8-bit pixels use a color palette\nto map to 24-bit color.\n\nCall pygame.Surface() to create a new image object. The Surface will\nbe cleared to all black. The only required arguments are the sizes. With no\nadditional arguments, the Surface will be created in a format that best\nmatches the display Surface.\n\nThe pixel format can be controlled by passing the bit depth or an existing\nSurface. The flags argument is a bitmask of additional features for the\nsurface. You can pass any combination of these flags:\n\nHWSURFACE    (obsolete in pygame 2) creates the image in video memory\nSRCALPHA     the pixel format will include a per-pixel alpha\n\nBoth flags are only a request, and may not be possible for all displays and\nformats.\n\nAdvanced users can combine a set of bitmasks with a depth value. The masks\nare a set of 4 integers representing which bits in a pixel will represent\neach color. Normal Surfaces should not require the masks argument.\n\nSurfaces can have many extra attributes like alpha planes, colorkeys, source\nrectangle clipping. These functions mainly effect how the Surface is blitted\nto other Surfaces. The blit routines will attempt to use hardware\nacceleration when possible, otherwise they will use highly optimized\nsoftware blitting methods.\n\nThere are three types of transparency supported in pygame: colorkeys,\nsurface alphas, and pixel alphas. Surface alphas can be mixed with\ncolorkeys, but an image with per pixel alphas cannot use the other modes.\nColorkey transparency makes a single color value transparent. Any pixels\nmatching the colorkey will not be drawn. The surface alpha value is a single\nvalue that changes the transparency for the entire image. A surface alpha of\n255 is opaque, and a value of 0 is completely transparent.\n\nPer pixel alphas are different because they store a transparency value for\nevery pixel. This allows for the most precise transparency effects, but it\nalso the slowest. Per pixel alphas cannot be mixed with surface alpha and\ncolorkeys.\n\nThere is support for pixel access for the Surfaces. Pixel access on hardware\nsurfaces is slow and not recommended. Pixels can be accessed using the\nget_at() and set_at() functions. These methods are fine for\nsimple access, but will be considerably slow when doing of pixel work with\nthem. If you plan on doing a lot of pixel level work, it is recommended to\nuse a pygame.PixelArray, which gives an array like view of the\nsurface. For involved mathematical manipulations try the\npygame.surfarray module (It's quite quick, but requires NumPy.)\n\nAny functions that directly access a surface's pixel data will need that\nsurface to be lock()'ed. These functions can lock() and\nunlock() the surfaces themselves without assistance. But, if a\nfunction will be called many times, there will be a lot of overhead for\nmultiple locking and unlocking of the surface. It is best to lock the\nsurface manually before making the function call many times, and then\nunlocking when you are finished. All functions that need a locked surface\nwill say so in their docs. Remember to leave the Surface locked only while\nnecessary.\n\nSurface pixels are stored internally as a single number that has all the\ncolors encoded into it. Use the map_rgb() and\nunmap_rgb() to convert between individual red, green, and blue\nvalues into a packed integer for that Surface.\n\nSurfaces can also reference sections of other Surfaces. These are created\nwith the subsurface() method. Any change to either Surface will\neffect the other.\n\nEach Surface contains a clipping area. By default the clip area covers the\nentire Surface. If it is changed, all drawing operations will only effect\nthe smaller area.\n\n"
#define DOC_SURFACE_BLIT "blit()\n\nDraw another surface onto this one.\n\nblit(source, dest=(0, 0), area=None, special_flags=0) -> Rect\n\nDraws another Surface onto this Surface.\n\nParameters\n\nsource\n\nThe Surface object to draw onto this Surface.\nIf it has transparency, transparent pixels will be ignored when blittting to an 8-bit Surface.\n\ndest (optional)\n\nThe source draw position onto this Surface, defaults to (0, 0).\nIt can be a coordinate pair (x, y) or a Rect (using its top-left corner).\nIf a Rect is passed, its size will not affect the blit.\n\narea (optional)\n\nThe rectangular portion of the source to draw.\nIt can be a Rect object representing that section. If None or not provided,\nthe entire source surface will be drawn.\nIf the Rect has negative position, the final blit position will be\ndest - Rect.topleft.\n\nspecial_flags (optional)\n\nControls how the colors of the source are combined with this Surface.\nIf not provided it defaults to BLENDMODE_NONE (0).\nSee special_flags_list for a list of possible values.\n\nReturn\n\nA rect object representing the affected area of this Surface that was modified\nby the blit operation. This area includes only the pixels within this Surface or\nits clipping area (see set_clip()).\nGenerally you don't need to use this return value, as it was initially designed to\npass it to pygame.display.update() to optimize the updating of the display.\nSince modern computers are fast enough to update the entire display at high speeds,\nthis return value is rarely used nowadays.\n\nExample Use\n\n# create a surface of size 50x50 and fill it with red color\nred_surf = pygame.Surface((50, 50))\nred_surf.fill(\"red\")\n\n# draw the surface on another surface at position (0, 0)\nanother_surface.blit(red_surf, (0, 0))\n\nNotes\n\nWhen self-blitting and there is a colorkey or alpha transparency set, resulting colors\nmay appear slightly different compared to a non-self blit.\n\nThe blit is ignored if the source is positioned completely outside this Surface's\nclipping area. Otherwise only the overlapping area will be drawn.\n\nChanged in pygame-ce 2.5.1: The dest argument is optional and defaults to (0, 0)"
#define DOC_SURFACE_BLITS "blits()\n\nDraw many surfaces onto this surface at their corresponding location.\n\nblits(blit_sequence, doreturn=1) -> Union[list[Rect], None]\n\nThe blits method efficiently draws a sequence of surfaces onto this Surface.\n\nParameters\n\nblit_sequence\n\nA sequence that contains each surface to be drawn along with its associated blit\narguments. See the Sequence Item Formats section below for the possible formats.\n\ndoreturn (optional)\n\nThe doreturn parameter controls the return value. When set to True, it returns\na list of rectangles representing the changed areas. When set to False, returns\nNone.\n\nReturn\n\nA list of rectangles or None.\n\nSequence Item Formats\n\n(source, dest)\n\nsource: Surface object to be drawn.\n\ndest: Position where the source Surface should be blitted.\n\n(source, dest, area)\n\narea: (optional) Specific area of the source Surface to be drawn.\n\n(source, dest, area, special_flags)\n\nspecial_flags: (optional) Controls the blending mode for drawing colors.\nSee special_flags_list for a list of possible values.\n\nNotes\n\nblits is an advanced method. It is recommended to read the documentation\nof blit() first.\n\nTo draw a Surface with a special flag, you must specify an area as well, e.g.,\n(source, dest, None, special_flags).\n\nPrefer using blits() over blit() when drawing multiple surfaces\nfor better performance. Use blit() if you need to draw a single surface.\n\nFor drawing a sequence of (source, dest) pairs with whole source Surface\nand a singular special_flag, use the fblits() method.\n\nNew in pygame 1.9.4."
#define DOC_SURFACE_FBLITS "fblits()\n\nDraw many surfaces onto this surface at their corresponding location and with the same special_flags.\n\nfblits(blit_sequence, special_flags=0, /) -> None\n\nThis method takes a sequence of tuples (source, dest) as input, where source is a Surface\nobject and dest is its destination position on this Surface. It draws each source Surface\nfully (meaning that unlike blit() you cannot pass an \"area\" parameter to represent\na smaller portion of the source Surface to draw) on this Surface with the same blending\nmode specified by special_flags.\n\nParameters\n\nblit_sequence -- a sequence of (source, dest)\n\nspecial_flags -- the flag(s) representing the blend mode used for each surface.\nSee special_flags_list for a list of possible values.\n\nReturns\n\nNone\n\nThis method only accepts a sequence of (source, dest) pairs and a single\nspecial_flags value that's applied to all surfaces drawn. This allows faster\niteration over the sequence and better performance over blits(). Further\noptimizations are applied if blit_sequence is a list or a tuple (using one\nof them is recommended).\n\nNew in pygame-ce 2.1.4."
#define DOC_SURFACE_CONVERT "convert()\n\nChange the pixel format of a surface.\n\nconvert(surface, /) -> Surface\n\nconvert(depth, flags=0, /) -> Surface\n\nconvert(masks, flags=0, /) -> Surface\n\nconvert() -> Surface\n\nCreates a new copy of the Surface with the pixel format changed. The new\npixel format can be determined from another existing Surface. Otherwise\ndepth, flags, and masks arguments can be used, similar to the\npygame.Surface() call.\n\nIf no arguments are passed the new Surface will have the same pixel\nformat as the display Surface. This is always the fastest format for\nblitting. It is a good idea to convert all Surfaces before they are\nblitted many times.\n\nThe converted Surface will have no pixel alphas. They will be stripped if\nthe original had them. See convert_alpha() for preserving or\ncreating per-pixel alphas.\n\nThe new copy will have the same class as the copied surface. This lets\na Surface subclass inherit this method without the need to override,\nunless subclass specific instance attributes also need copying.\n\nChanged in pygame-ce 2.5.0: converting to a known format will succeed without\na window/display surface."
#define DOC_SURFACE_CONVERTALPHA "convert_alpha()\n\nChange the pixel format of a surface including per pixel alphas.\n\nconvert_alpha() -> Surface\n\nCreates a new copy of the surface with the desired pixel format. The new\nsurface will be in a format suited for quick blitting to the display surface\nwith per pixel alpha.\n\nUnlike the convert() method, the pixel format for the new\nsurface will not be exactly the same as the display surface, but it will\nbe optimized for fast alpha blitting to it.\n\nAs with convert() the returned surface has the same class as\nthe converted surface.\n\nChanged in pygame-ce 2.4.0: 'Surface' argument deprecated."
#define DOC_SURFACE_COPY "copy()\n\nCreate a new copy of a Surface.\n\ncopy() -> Surface\n\nMakes a duplicate copy of a Surface. The new surface will have the same\npixel formats, color palettes, transparency settings, and class as the\noriginal. If a Surface subclass also needs to copy any instance specific\nattributes then it should override copy(). Shallow copy and deepcopy\nare supported, Surface implements __copy__ and __deepcopy__ respectively.\n\nNew in pygame-ce 2.3.1: Added support for deepcopy by implementing __deepcopy__, calls copy() internally."
#define DOC_SURFACE_FILL "fill()\n\nFill Surface with a solid color.\n\nfill(color, rect=None, special_flags=0) -> Rect\n\nFill the Surface with a solid color. If no rect argument is given the\nentire Surface will be filled. The rect argument will limit the fill to a\nspecific area. The fill will also be contained by the Surface clip area.\n\nThe color argument should be compatible with pygame.typing.ColorLike.\nIf using RGBA, the Alpha (A part of RGBA) is ignored unless the surface\nuses per pixel alpha (Surface has the SRCALPHA flag).\n\nThe special_flags argument controls how the colors are combined. See special_flags_list\nfor a list of possible values.\n\nThis will return the affected Surface area.\n\nAs of pygame-ce version 2.5.1, a long-standing bug has been fixed!\nNow when passing in a Rect with negative x or negative y (or both),\nthe Rect filled will no longer be shifted to (0, 0), but instead only the\npart of the Rect overlapping the window's Rect will be filled."
#define DOC_SURFACE_SCROLL "scroll()\n\nShift the Surface pixels in place.\n\nscroll(dx=0, dy=0, scroll_flag=0, /) -> None\n\nMove the Surface by dx pixels right and dy pixels down. dx and dy may be\nnegative for left and up scrolls respectively.\n\nScrolling is contained by the Surface clip area. It is safe to have dx\nand dy values that exceed the surface size.\n\nThe scroll flag can be:\n\n0 (default): the pixels are shifted but previous pixels are\nnot modified.\n\npygame.SCROLL_ERASE: the space created by the shifting pixels\nis filled with black or transparency.\n\npygame.SCROLL_REPEAT: the pixels that disappear out of the\nsurface or clip bounds are brought back on the opposite side\nresulting in an infinitely scrolling and repeating surface.\n\nNew in pygame 1.9.\n\nChanged in pygame-ce 2.5.3: Add repeating scroll and allow erasing pixels"
#define DOC_SURFACE_SETCOLORKEY "set_colorkey()\n\nSet the transparent colorkey.\n\nset_colorkey(color, flags=0, /) -> None\n\nset_colorkey(color, /) -> None\n\nSet the current color key for the Surface. When blitting this Surface\nonto a destination, any pixels that have the same color as the colorkey\nwill be transparent. The color should be compatible with pygame.typing.ColorLike.\nIf None is passed, the colorkey will be unset.\n\nThe colorkey will be ignored if the Surface is formatted to use per pixel\nalpha values. The colorkey can be mixed with the full Surface alpha\nvalue.\n\nThe optional flags argument can be set to pygame.RLEACCEL to provide\nbetter performance on non accelerated displays. An RLEACCEL Surface\nwill be slower to modify, but quicker to blit as a source."
#define DOC_SURFACE_GETCOLORKEY "get_colorkey()\n\nGet the current transparent colorkey.\n\nget_colorkey() -> Optional[tuple[int, int, int, int]]\n\nReturn the current colorkey value for the Surface. If the colorkey is not\nset then None is returned."
#define DOC_SURFACE_SETALPHA "set_alpha()\n\nSet the alpha value for the full Surface.\n\nset_alpha(value, flags=0, /) -> None\n\nset_alpha(value, /) -> None\n\nSet the current alpha value for the Surface. When blitting this Surface\nonto a destination, the pixels will be drawn slightly transparent. The\nalpha value is an integer from 0 to 255, 0 is fully transparent and 255\nis fully opaque. If None is passed for the alpha value, then alpha\nblending will be disabled, including per-pixel alpha.\n\nThis value is different than the per pixel Surface alpha. For a surface\nwith per pixel alpha, blanket alpha is ignored and None is returned.\n\nChanged in pygame 2.0: per-surface alpha can be combined with per-pixel\nalpha.\n\nThe optional flags argument can be set to pygame.RLEACCEL to provide\nbetter performance on non accelerated displays. An RLEACCEL Surface\nwill be slower to modify, but quicker to blit as a source."
#define DOC_SURFACE_GETALPHA "get_alpha()\n\nGet the current Surface transparency value.\n\nget_alpha() -> Optional[int]\n\nReturn the current alpha value for the Surface."
#define DOC_SURFACE_LOCK "lock()\n\nLock the Surface memory for pixel access.\n\nlock() -> None\n\nLock the pixel data of a Surface for access. On accelerated Surfaces, the\npixel data may be stored in volatile video memory or nonlinear compressed\nforms. When a Surface is locked the pixel memory becomes available to\naccess by regular software. Code that reads or writes pixel values will\nneed the Surface to be locked.\n\nSurfaces should not remain locked for more than necessary. A locked\nSurface can often not be displayed or managed by pygame.\n\nNot all Surfaces require locking. The mustlock() method can\ndetermine if it is actually required. There is no performance penalty for\nlocking and unlocking a Surface that does not need it.\n\nAll pygame functions will automatically lock and unlock the Surface data\nas needed. If a section of code is going to make calls that will\nrepeatedly lock and unlock the Surface many times, it can be helpful to\nwrap the block inside a lock and unlock pair.\n\nIt is safe to nest locking and unlocking calls. The surface will only be\nunlocked after the final lock is released."
#define DOC_SURFACE_UNLOCK "unlock()\n\nUnlock the Surface memory from pixel access.\n\nunlock() -> None\n\nUnlock the Surface pixel data after it has been locked. The unlocked\nSurface can once again be drawn and managed by pygame. See the\nlock() documentation for more details.\n\nAll pygame functions will automatically lock and unlock the Surface data\nas needed. If a section of code is going to make calls that will\nrepeatedly lock and unlock the Surface many times, it can be helpful to\nwrap the block inside a lock and unlock pair.\n\nIt is safe to nest locking and unlocking calls. The surface will only be\nunlocked after the final lock is released."
#define DOC_SURFACE_MUSTLOCK "mustlock()\n\nTest if the Surface requires locking.\n\nmustlock() -> bool\n\nReturns True if the Surface is required to be locked to access pixel\ndata. Usually pure software Surfaces do not require locking. This method\nis rarely needed, since it is safe and quickest to just lock all Surfaces\nas needed.\n\nAll pygame functions will automatically lock and unlock the Surface data\nas needed. If a section of code is going to make calls that will\nrepeatedly lock and unlock the Surface many times, it can be helpful to\nwrap the block inside a lock and unlock pair."
#define DOC_SURFACE_GETLOCKED "get_locked()\n\nTest if the Surface is current locked.\n\nget_locked() -> bool\n\nReturns True when the Surface is locked. It doesn't matter how many\ntimes the Surface is locked."
#define DOC_SURFACE_GETLOCKS "get_locks()\n\nGets the locks for the Surface.\n\nget_locks() -> tuple[Any, ...]\n\nReturns the currently existing locks for the Surface."
#define DOC_SURFACE_GETAT "get_at()\n\nGet the color value at a single pixel.\n\nget_at(x_y, /) -> Color\n\nReturn a copy of the RGBA Color value at the given pixel. If the\nSurface has no per pixel alpha, then the alpha value will always be 255\n(opaque). If the pixel position is outside the area of the Surface an\nIndexError exception will be raised.\n\nGetting and setting pixels one at a time is generally too slow to be used\nin a game or realtime situation. It is better to use methods which\noperate on many pixels at a time like with the blit, fill and draw\nmethods - or by using pygame.surfarray/pygame.PixelArray.\n\nThis function will temporarily lock and unlock the Surface as needed.\n\nChanged in pygame-ce 2.3.1: can now also accept both float coordinates and\nVector2s for pixels.\n\nChanged in pygame 1.9: Returning a Color instead of tuple. Use tuple(surf.get_at((x,y)))\nif you want a tuple, and not a Color. This should only matter if\nyou want to use the color as a key in a dict."
#define DOC_SURFACE_SETAT "set_at()\n\nSet the color value for a single pixel.\n\nset_at(x_y, color, /) -> None\n\nSet the color of a single pixel at the specified coordinates to be a\npygame.typing.ColorLike value. If the Surface does not have per pixel alphas,\nthe alpha value is ignored. Setting pixels outside the Surface area or outside\nthe Surface clipping will have no effect.\n\nGetting and setting pixels one at a time is generally too slow to be used\nin a game or realtime situation.\n\nThis function will temporarily lock and unlock the Surface as needed.\n\nIf the surface is palettized, the pixel color will be set to the\nmost similar color in the palette.\n\nChanged in pygame-ce 2.3.1: can now also accept both float coordinates and\nVector2s for pixels."
#define DOC_SURFACE_GETATMAPPED "get_at_mapped()\n\nGet the mapped color value at a single pixel.\n\nget_at_mapped(x_y, /) -> int\n\nReturn the integer value of the given pixel. If the pixel position is\noutside the area of the Surface an IndexError exception will be\nraised.\n\nThis method is intended for pygame unit testing. It unlikely has any use\nin an application.\n\nThis function will temporarily lock and unlock the Surface as needed.\n\nNew in pygame 1.9.2.\n\nChanged in pygame-ce 2.3.1: can now also accept both float coordinates and\nVector2s for pixels."
#define DOC_SURFACE_GETPALETTE "get_palette()\n\nGet the color index palette for an 8-bit Surface.\n\nget_palette() -> list[Color]\n\nReturn a list of up to 256 color elements that represent the indexed\ncolors used in an 8-bit Surface. The returned list is a copy of the\npalette, and changes will have no effect on the Surface.\n\nReturning a list of Color(with length 3) instances instead of tuples.\n\nNew in pygame 1.9."
#define DOC_SURFACE_GETPALETTEAT "get_palette_at()\n\nGet the color for a single entry in a palette.\n\nget_palette_at(index, /) -> Color\n\nReturns the red, green, and blue color values for a single index in a\nSurface palette. The index should be a value from 0 to 255.\n\nNew in pygame 1.9: Returning Color(with length 3) instance instead of a tuple."
#define DOC_SURFACE_SETPALETTE "set_palette()\n\nSet the color palette for an 8-bit Surface.\n\nset_palette(palette, /) -> None\n\nSet the full palette for an 8-bit Surface. This will replace the colors in\nthe existing palette. A partial palette can be passed and only the first\ncolors in the original palette will be changed.\n\nThis function has no effect on a Surface with more than 8-bits per pixel."
#define DOC_SURFACE_SETPALETTEAT "set_palette_at()\n\nSet the color for a single index in an 8-bit Surface palette.\n\nset_palette_at(index, color, /) -> None\n\nSet the palette value for a single entry in a Surface palette. The index\nshould be a value from 0 to 255.\n\nThis function has no effect on a Surface with more than 8-bits per pixel."
#define DOC_SURFACE_MAPRGB "map_rgb()\n\nConvert a color into a mapped color value.\n\nmap_rgb(color, /) -> int\n\nConvert a pygame.typing.ColorLike into the mapped integer value\nfor this Surface. The returned integer will contain no more bits than the\nbit depth of the Surface. Mapped color values are not often used inside pygame,\nbut can be passed to most functions that require a Surface and a color.\n\nSee the Surface object documentation for more information about colors\nand pixel formats."
#define DOC_SURFACE_UNMAPRGB "unmap_rgb()\n\nConvert a mapped integer color value into a Color.\n\nunmap_rgb(mapped_int, /) -> Color\n\nConvert an mapped integer color into the RGB color components for\nthis Surface. Mapped color values are not often used inside pygame, but\ncan be passed to most functions that require a Surface and a color.\n\nSee the Surface object documentation for more information about colors\nand pixel formats."
#define DOC_SURFACE_SETCLIP "set_clip()\n\nSet the current clipping area of the Surface.\n\nset_clip(rect, /) -> None\n\nEach Surface has an active clipping area. This is a rectangle that\nrepresents the only pixels on the Surface that can be modified. If\nNone is passed for the rectangle the full Surface will be available\nfor changes.\n\nThe clipping area is always restricted to the area of the Surface itself.\nIf the clip rectangle is too large it will be shrunk to fit inside the\nSurface."
#define DOC_SURFACE_GETCLIP "get_clip()\n\nGet the current clipping area of the Surface.\n\nget_clip() -> Rect\n\nReturn a rectangle of the current clipping area. The Surface will always\nreturn a valid rectangle that will never be outside the bounds of the\nsurface. If the Surface has had None set for the clipping area, the\nSurface will return a rectangle with the full area of the Surface."
#define DOC_SURFACE_SUBSURFACE "subsurface()\n\nCreate a new surface that references its parent.\n\nsubsurface(rect, /) -> Surface\n\nsubsurface(left_top, width_height, /) -> Surface\n\nsubsurface(left, top, width, height, /) -> Surface\n\nReturns a new Surface that shares its pixels with its new parent. The new\nSurface is considered a child of the original. Modifications to either\nSurface pixels will effect each other. Surface information like clipping\narea and color keys are unique to each Surface.\n\nThe new Surface will inherit the palette, color key, and alpha settings\nfrom its parent.\n\nIt is possible to have any number of subsurfaces and subsubsurfaces on\nthe parent. It is also possible to subsurface the display Surface if the\ndisplay mode is not hardware accelerated.\n\nSee get_offset() and get_parent() to learn more\nabout the state of a subsurface.\n\nA subsurface will have the same class as the parent surface."
#define DOC_SURFACE_GETPARENT "get_parent()\n\nFind the parent of a subsurface.\n\nget_parent() -> Surface\n\nReturns the parent Surface of a subsurface. If this is not a subsurface\nthen None will be returned."
#define DOC_SURFACE_GETABSPARENT "get_abs_parent()\n\nFind the top level parent of a subsurface.\n\nget_abs_parent() -> Surface\n\nReturns the parent Surface of a subsurface. If this is not a subsurface\nthen this surface will be returned."
#define DOC_SURFACE_GETOFFSET "get_offset()\n\nFind the position of a child subsurface inside a parent.\n\nget_offset() -> tuple[int, int]\n\nGet the offset position of a child subsurface inside of a parent. If the\nSurface is not a subsurface this will return (0, 0)."
#define DOC_SURFACE_GETABSOFFSET "get_abs_offset()\n\nFind the absolute position of a child subsurface inside its top level parent.\n\nget_abs_offset() -> tuple[int, int]\n\nGet the offset position of a child subsurface inside of its top level\nparent Surface. If the Surface is not a subsurface this will return (0,\n0)."
#define DOC_SURFACE_GETSIZE "get_size()\n\nGet the dimensions of the Surface.\n\nget_size() -> tuple[int, int]\n\nReturn the width and height of the Surface in pixels. Can also be accessed\nwith size"
#define DOC_SURFACE_GETWIDTH "get_width()\n\nGet the width of the Surface.\n\nget_width() -> int\n\nReturn the width of the Surface in pixels. Can also be accessed with width"
#define DOC_SURFACE_GETHEIGHT "get_height()\n\nGet the height of the Surface.\n\nget_height() -> int\n\nReturn the height of the Surface in pixels. Can also be accessed with height"
#define DOC_SURFACE_GETRECT "get_rect()\n\nGet the rectangular area of the Surface.\n\nget_rect(**kwargs) -> Rect\n\nReturns a new rectangle covering the entire surface. This rectangle will\nalways start at (0, 0) with a width and height the same size as the surface.\n\nYou can pass keyword argument values to this function. These named values\nwill be applied to the attributes of the Rect before it is returned. An\nexample would be mysurf.get_rect(center=(100, 100)) to create a\nrectangle for the Surface centered at a given position. Size attributes\nsuch as size or w can also be applied to resize the Rect."
#define DOC_SURFACE_GETFRECT "get_frect()\n\nGet the rectangular area of the Surface.\n\nget_frect(**kwargs) -> FRect\n\nThis is the same as Surface.get_rect() but returns an FRect. FRect is similar\nto Rect, except it stores float values instead.\n\nYou can pass keyword argument values to this function. These named values\nwill be applied to the attributes of the FRect before it is returned. An\nexample would be mysurf.get_frect(center=(100.5, 100.5)) to create a\nrectangle for the Surface centered at a given position. Size attributes\nsuch as size or w can also be applied to resize the FRect.\n\n..versionadded:: 2.3.0"
#define DOC_SURFACE_GETBITSIZE "get_bitsize()\n\nGet the bit depth of the Surface pixel format.\n\nget_bitsize() -> int\n\nReturns the number of bits used to represent each pixel. This value may\nnot exactly fill the number of bytes used per pixel. For example a 15 bit\nSurface still requires a full 2 bytes."
#define DOC_SURFACE_GETBYTESIZE "get_bytesize()\n\nGet the bytes used per Surface pixel.\n\nget_bytesize() -> int\n\nReturn the number of bytes used per pixel."
#define DOC_SURFACE_GETFLAGS "get_flags()\n\nGet the additional flags used for the Surface.\n\nget_flags() -> int\n\nReturns a set of current Surface features. Each feature is a bit in the\nflags bitmask. Typical flags are RLEACCEL, SRCALPHA, and\nSRCCOLORKEY.\n\nHere is a more complete list of flags. A full list can be found in\nSDL_video.h\n\nSWSURFACE      0x00000000    # Surface is in system memory\nHWSURFACE      0x00000001    # (obsolete in pygame 2) Surface is in video memory\nASYNCBLIT      0x00000004    # (obsolete in pygame 2) Use asynchronous blits if possible\n\nSee pygame.display.set_mode() for flags exclusive to the\ndisplay surface.\n\nUsed internally (read-only)\n\nHWACCEL        0x00000100    # Blit uses hardware acceleration\nSRCCOLORKEY    0x00001000    # Blit uses a source color key\nRLEACCELOK     0x00002000    # Private flag\nRLEACCEL       0x00004000    # Surface is RLE encoded\nSRCALPHA       0x00010000    # Blit uses source alpha blending\nPREALLOC       0x01000000    # Surface uses preallocated memory"
#define DOC_SURFACE_GETPITCH "get_pitch()\n\nGet the number of bytes used per Surface row.\n\nget_pitch() -> int\n\nReturn the number of bytes separating each row in the Surface. Surfaces\nin video memory are not always linearly packed. Subsurfaces will also\nhave a larger pitch than their real width.\n\nThis value is not needed for normal pygame usage."
#define DOC_SURFACE_GETMASKS "get_masks()\n\nThe bitmasks needed to convert between a color and a mapped integer.\n\nget_masks() -> tuple[int, int, int, int]\n\nReturns the bitmasks used to isolate each color in a mapped integer.\n\nThis value is not needed for normal pygame usage."
#define DOC_SURFACE_SETMASKS "set_masks()\n\nSet the bitmasks needed to convert between a color and a mapped integer.\n\nset_masks(color, /) -> None\n\nThis is not needed for normal pygame usage.\n\nStarting in pygame 2.0, the masks are read-only and\naccordingly this method will raise a TypeError if called.\n\nDeprecated since pygame 2.0.0.\n\nNew in pygame 1.8.1."
#define DOC_SURFACE_GETSHIFTS "get_shifts()\n\nThe bit shifts needed to convert between a color and a mapped integer.\n\nget_shifts() -> tuple[int, int, int, int]\n\nReturns the pixel shifts need to convert between each color and a mapped\ninteger.\n\nThis value is not needed for normal pygame usage."
#define DOC_SURFACE_SETSHIFTS "set_shifts()\n\nSets the bit shifts needed to convert between a color and a mapped integer.\n\nset_shifts(color, /) -> None\n\nThis is not needed for normal pygame usage.\n\nStarting in pygame 2.0, the shifts are read-only and\naccordingly this method will raise a TypeError if called.\n\nDeprecated since pygame 2.0.0.\n\nNew in pygame 1.8.1."
#define DOC_SURFACE_GETLOSSES "get_losses()\n\nThe significant bits used to convert between a color and a mapped integer.\n\nget_losses() -> tuple[int, int, int, int]\n\nReturn the least significant number of bits stripped from each color in a\nmapped integer.\n\nThis value is not needed for normal pygame usage."
#define DOC_SURFACE_GETBOUNDINGRECT "get_bounding_rect()\n\nFind the smallest rect containing data.\n\nget_bounding_rect(min_alpha=1) -> Rect\n\nReturns the smallest rectangular region that contains all the pixels in\nthe surface that have an alpha value greater than or equal to the minimum\nalpha value.\n\nThis function will temporarily lock and unlock the Surface as needed.\n\nNew in pygame 1.8."
#define DOC_SURFACE_GETVIEW "get_view()\n\nReturn a buffer view of the Surface's pixels.\n\nget_view(kind='2', /) -> BufferProxy\n\nReturn an object which exports a surface's internal pixel buffer as\na C level array struct, Python level array interface or a C level\nbuffer interface. The new buffer protocol is supported.\n\nThe kind argument is the length 1 string '0', '1', '2', '3',\n'r', 'g', 'b', or 'a'. The letters are case insensitive;\n'A' will work as well. The argument can be either a Unicode or byte (char)\nstring. The default is '2'.\n\n'0' returns a contiguous unstructured bytes view. No surface shape\ninformation is given. A ValueError is raised if the surface's pixels\nare discontinuous.\n\n'1' returns a (surface-width * surface-height) array of continuous\npixels. A ValueError is raised if the surface pixels are\ndiscontinuous.\n\n'2' returns a (surface-width, surface-height) array of raw pixels.\nThe pixels are surface-bytesize-d unsigned integers. The pixel format is\nsurface specific. The 3 byte unsigned integers of 24 bit surfaces are\nunlikely accepted by anything other than other pygame functions.\n\n'3' returns a (surface-width, surface-height, 3) array of RGB color\ncomponents. Each of the red, green, and blue components are unsigned\nbytes. Only 24-bit and 32-bit surfaces are supported. The color\ncomponents must be in either RGB or BGR order within the pixel.\n\n'r' for red, 'g' for green, 'b' for blue, and 'a' for alpha return a\n(surface-width, surface-height) view of a single color component within a\nsurface: a color plane. Color components are unsigned bytes. Both 24-bit\nand 32-bit surfaces support 'r', 'g', and 'b'. Only 32-bit surfaces with\nSRCALPHA support 'a'.\n\nThe surface is locked only when an exposed interface is accessed.\nFor new buffer interface accesses, the surface is unlocked once the\nlast buffer view is released. For array interface and old buffer\ninterface accesses, the surface remains locked until the BufferProxy\nobject is released.\n\nNew in pygame 1.9.2."
#define DOC_SURFACE_GETBUFFER "get_buffer()\n\nAcquires a buffer object for the pixels of the Surface.\n\nget_buffer() -> BufferProxy\n\nReturn a buffer object for the pixels of the Surface. The buffer can be\nused for direct pixel access and manipulation. Surface pixel data is\nrepresented as an unstructured block of memory, with a start address\nand length in bytes. The data need not be contiguous. Any gaps are\nincluded in the length, but otherwise ignored.\n\nThis method implicitly locks the Surface. The lock will be released when\nthe returned pygame.BufferProxy object is garbage collected.\n\nNew in pygame 1.8."
#define DOC_SURFACE_PIXELSADDRESS "property _pixels_address\n\nPixel buffer address.\n\n_pixels_address -> int\n\nThe starting address of the surface's raw pixel bytes.\n\nNew in pygame 1.9.2."
#define DOC_SURFACE_PREMULALPHA "premul_alpha()\n\nReturns a copy of the surface with the RGB channels pre-multiplied by the alpha channel.\n\npremul_alpha() -> Surface\n\nReturns a copy of the initial surface with the red, green and blue color\nchannels multiplied by the alpha channel. This is intended to make it\neasier to work with the BLEND_PREMULTIPLED blend mode flag of the blit()\nmethod. Surfaces which have called this method will only look correct\nafter blitting if the BLEND_PREMULTIPLED special flag is used.\n\nIt is worth noting that after calling this method, methods that return the\ncolor of a pixel such as get_at() will return the alpha multiplied color\nvalues. It is not possible to fully reverse an alpha multiplication of\nthe colors in a surface as integer color channel data is generally\nreduced by the operation (e.g. 255 x 0 = 0, from there it is not\npossible to reconstruct the original 255 from just the two remaining\nzeros in the color and alpha channels).\n\nIf you call this method, and then call it again, it will multiply the color\nchannels by the alpha channel twice. There are many possible ways to obtain\na surface with the color channels pre-multiplied by the alpha channel in\npygame, and it is not possible to tell the difference just from the\ninformation in the pixels. It is completely possible to have two identical\nsurfaces - one intended for pre-multiplied alpha blending and one intended\nfor normal blending. For this reason we do not store state on surfaces\nintended for pre-multiplied alpha blending.\n\nSurfaces without an alpha channel cannot use this method and will return\nan error if you use it on them. It is best used on 32 bit surfaces (the\ndefault on most platforms) as the blitting on these surfaces can be\naccelerated by SIMD versions of the pre-multiplied blitter.\n\nIn general pre-multiplied alpha blitting is faster then 'straight alpha'\nblitting and produces superior results when blitting an alpha surface onto\nanother surface with alpha - assuming both surfaces contain pre-multiplied\nalpha colors.\n\nThere is a tutorial on premultiplied alpha blending here.\n\nNew in pygame-ce 2.1.4."
#define DOC_SURFACE_PREMULALPHAIP "premul_alpha_ip()\n\nMultiplies the RGB channels by the surface alpha channel.\n\npremul_alpha_ip() -> Surface\n\nMultiplies the RGB channels of the surface by the alpha channel in place\nand returns the surface.\n\nSurfaces without an alpha channel cannot use this method and will return\nan error if you use it on them. It is best used on 32 bit surfaces (the\ndefault on most platforms) as the blitting on these surfaces can be\naccelerated by SIMD versions of the pre-multiplied blitter.\n\nRefer to the premul_alpha() method for more information.\n\nNew in pygame-ce 2.5.1."
#define DOC_SURFACE_WIDTH "property width\n\nSurface width in pixels (read-only).\n\nwidth -> int\n\nRead-only attribute. Same as get_width()\n\nNew in pygame-ce 2.5.0."
#define DOC_SURFACE_HEIGHT "property height\n\nSurface height in pixels (read-only).\n\nheight -> int\n\nRead-only attribute. Same as get_height()\n\nNew in pygame-ce 2.5.0."
#define DOC_SURFACE_SIZE "property size\n\nSurface size in pixels (read-only).\n\nsize -> tuple[int, int]\n\nRead-only attribute. Same as get_size()\n\nNew in pygame-ce 2.5.0."
