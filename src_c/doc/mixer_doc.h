/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_MIXER "pygame.mixer\n\n\n\npygame module for loading and playing sounds\n\nThis module contains classes for loading Sound objects and controlling\nplayback.\n\nThe mixer module has a limited number of channels for playback of sounds.\nUsually programs tell pygame to start playing audio and it selects an available\nchannel automatically. The default is 8 simultaneous channels, but complex\nprograms can get more precise control over the number of channels and their\nuse.\n\nAll sound playback is mixed in background threads. When you begin to play a\nSound object, it will return immediately while the sound continues to play. A\nsingle Sound object can also be actively played back multiple times.\n\nThe mixer also has a special streaming channel. This is for music playback and\nis accessed through the pygame.mixer.music module. Consider using this\nmodule for playing long running music. Unlike mixer module, the music module\nstreams the music from the files without loading music at once into memory.\n\nThe mixer module must be initialized like other pygame modules, but it has some\nextra conditions. The pygame.mixer.init() function takes several optional\narguments to control the playback rate and sample size.\n\nNOTE: For less laggy sound use a smaller buffer size. The default\nis set to reduce the chance of scratchy sounds on some computers. You can\nchange the default buffer by calling pygame.mixer.pre_init() before\npygame.mixer.init() or pygame.init() is called. For example:\npygame.mixer.pre_init(44100,-16,2, 1024)\n\nThe following file formats are supported\n\nWAV\n\nMP3\n\nOGG\n\nFLAC\n\nOPUS\n\nWV (WavPack)\n\nMOD (\"Module file\" family of music file formats)\n\nMIDI (see the get_soundfont() and set_soundfont() methods)\n\nNew in pygame-ce 2.5.0: Loading WV (Relies on SDL_mixer 2.8.0+)"
#define DOC_MIXER_INIT "pygame.mixer.init()\n\ninitialize the mixer module\n\ninit(frequency=44100, size=-16, channels=2, buffer=512, devicename=None, allowedchanges=AUDIO_ALLOW_FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE) -> None\n\nInitialize the mixer module for Sound loading and playback. The default\narguments can be overridden to provide specific audio mixing. Keyword\narguments are accepted. For backwards compatibility, argument values of\n0 are replaced with the startup defaults, except for allowedchanges,\nwhere -1 is used. (startup defaults may be changed by a pre_init() call).\n\nThe size argument represents how many bits are used for each audio sample.\nIf the value is negative then signed sample values will be used. Positive\nvalues mean unsigned audio samples will be used. An invalid value raises an\nexception.\n\nThe channels argument is used to specify whether to use mono or stereo. 1\nfor mono and 2 for stereo.\nNOTE: The channels argument is not related to the number\nof channels for playback of sounds, that you can get with the function\n\"get_num_channels\" or set with the function \"set_num_channels\" (see below).\n\nThe buffer argument controls the number of internal samples used in the\nsound mixer. The default value should work for most cases. It can be lowered\nto reduce latency, but sound dropout may occur. It can be raised to larger\nvalues to ensure playback never skips, but it will impose latency on sound\nplayback. The buffer size must be a power of two (if not it is rounded up to\nthe next nearest power of 2).\n\nThe devicename parameter is the name of sound device to open for audio\nplayback. Allowed device names will vary based on the host system.\nIf left as None then a sensible default will be chosen for you.\n\nSome platforms require the pygame.mixer module to be initialized\nafter the display modules have initialized. The top level pygame.init()\ntakes care of this automatically, but cannot pass any arguments to the mixer\ninit. To solve this, mixer has a function pygame.mixer.pre_init() to set\nthe proper defaults before the toplevel init is used.\n\nWhen using allowedchanges=0 it will convert the samples at runtime to match\nwhat the hardware supports. For example a sound card may not\nsupport 16bit sound samples, so instead it will use 8bit samples internally.\nIf AUDIO_ALLOW_FORMAT_CHANGE is supplied, then the requested format will\nchange to the closest that SDL supports.\n\nApart from 0, allowedchanged accepts the following constants ORed together:\n\nAUDIO_ALLOW_FREQUENCY_CHANGE\n\nAUDIO_ALLOW_FORMAT_CHANGE\n\nAUDIO_ALLOW_CHANNELS_CHANGE\n\nAUDIO_ALLOW_ANY_CHANGE\n\nIt is safe to call this more than once, but after the mixer is initialized\nyou cannot change the playback arguments without first calling\npygame.mixer.quit().\n\nChanged in pygame 1.8: The default buffersize changed from 1024 to 3072.\n\nChanged in pygame 1.9.1: The default buffersize changed from 3072 to 4096.\n\nChanged in pygame 2.0.0: The default buffersize changed from 4096 to 512.\n\nChanged in pygame 2.0.0: The default frequency changed from 22050 to 44100.\n\nChanged in pygame 2.0.0: size can be 32 (32-bit floats).\n\nChanged in pygame 2.0.0: channels can also be 4 or 6.\n\nNew in pygame 2.0.0: allowedchanges, devicename arguments added"
#define DOC_MIXER_PREINIT "pygame.mixer.pre_init()\n\npreset the mixer init arguments\n\npre_init(frequency=44100, size=-16, channels=2, buffer=512, devicename=None, allowedchanges=AUDIO_ALLOW_FREQUENCY_CHANGE | AUDIO_ALLOW_CHANNELS_CHANGE) -> None\n\nCall pre_init to change the defaults used when the real\npygame.mixer.init() is called. Keyword arguments are accepted. The best\nway to set custom mixer playback values is to call\npygame.mixer.pre_init() before calling the top level pygame.init().\nFor backwards compatibility, argument values of 0 are replaced with the\nstartup defaults, except for allowedchanges, where -1 is used.\n\nChanged in pygame 1.8: The default buffersize changed from 1024 to 3072.\n\nChanged in pygame 1.9.1: The default buffersize changed from 3072 to 4096.\n\nChanged in pygame 2.0.0: The default buffersize changed from 4096 to 512.\n\nChanged in pygame 2.0.0: The default frequency changed from 22050 to 44100.\n\nNew in pygame 2.0.0: allowedchanges, devicename arguments added"
#define DOC_MIXER_QUIT "pygame.mixer.quit()\n\nuninitialize the mixer\n\nquit() -> None\n\nThis will uninitialize pygame.mixer. All playback will stop and any\nloaded Sound objects may not be compatible with the mixer if it is\nreinitialized later."
#define DOC_MIXER_GETINIT "pygame.mixer.get_init()\n\ntest if the mixer is initialized\n\nget_init() -> (frequency, format, channels)\n\nIf the mixer is initialized, this returns the playback arguments it is\nusing. If the mixer has not been initialized this returns None."
#define DOC_MIXER_GETDRIVER "pygame.mixer.get_driver()\n\nget the name of the current audio backend driver\n\nget_driver() -> str\n\nPygame chooses one of many available audio backend drivers when it is\ninitialized. This returns the internal name used for the backend. This\nfunction is intended to be used for getting diagnostic/debugging information.\nThis can be controlled with SDL_AUDIODRIVER environment variable.\n\nNew in pygame-ce 2.5.0."
#define DOC_MIXER_STOP "pygame.mixer.stop()\n\nstop playback of all sound channels\n\nstop() -> None\n\nThis will stop all playback of all active mixer channels."
#define DOC_MIXER_PAUSE "pygame.mixer.pause()\n\ntemporarily stop playback of all sound channels\n\npause() -> None\n\nThis will temporarily stop all playback on the active mixer channels. The\nplayback can later be resumed with pygame.mixer.unpause()"
#define DOC_MIXER_UNPAUSE "pygame.mixer.unpause()\n\nresume paused playback of sound channels\n\nunpause() -> None\n\nThis will resume all active sound channels after they have been paused."
#define DOC_MIXER_FADEOUT "pygame.mixer.fadeout()\n\nfade out the volume on all sounds before stopping\n\nfadeout(time, /) -> None\n\nThis will fade out the volume on all active channels over the time argument\nin milliseconds. After the sound is muted the playback will stop."
#define DOC_MIXER_SETNUMCHANNELS "pygame.mixer.set_num_channels()\n\nset the total number of playback channels\n\nset_num_channels(count, /) -> None\n\nSets the number of available playback channels for the mixer. The default value is 8.\nThe value can be increased or decreased. If the value is decreased, sounds\nplaying on the truncated channels are stopped."
#define DOC_MIXER_GETNUMCHANNELS "pygame.mixer.get_num_channels()\n\nget the total number of playback channels\n\nget_num_channels() -> count\n\nReturns the number of currently active playback channels."
#define DOC_MIXER_SETRESERVED "pygame.mixer.set_reserved()\n\nreserve channels from being automatically used\n\nset_reserved(count, /) -> count\n\nThe mixer can reserve any number of channels that will not be automatically\nselected for playback by Sounds. This means that whenever you play a Sound\nwithout specifying a channel, a reserved channel will never be used. If sounds\nare currently playing on the reserved channels they will not be stopped.\n\nThis allows the application to reserve a specific number of channels for\nimportant sounds that must not be dropped or have a guaranteed channel to\nplay on.\n\nWill return number of channels actually reserved, this may be less than requested\ndepending on the number of channels previously allocated."
#define DOC_MIXER_FINDCHANNEL "pygame.mixer.find_channel()\n\nfind an unused channel\n\nfind_channel(force=False) -> Channel\n\nThis will find and return an inactive Channel object. If there are no\ninactive Channels this function will return None. If there are no\ninactive channels and the force argument is True, this will find the\nChannel with the longest running Sound and return it."
#define DOC_MIXER_SETSOUNDFONT "pygame.mixer.set_soundfont()\n\nset the soundfont for playing midi music\n\nset_soundfont(path, /) -> None\n\nThis sets the soundfont file to be used in the playback of midi music.\nThe soundfont only affects the playback of MID, MIDI, and KAR file formats.\nThe optional path argument, a string (or multiple strings separated by a semi-colon),\nmust point to the soundfont file(s) to be searched for in order given if some\nare missing. If path is an empty string or the default (None), any specified soundfont paths\nwill be cleared from the mixer.\n\nNote on Windows, the mixer always uses the built-in soundfont instead of the one specified.\n\nFunction set_soundfont() calls underlying SDL_mixer function\nMix_SetSoundFonts.\n\nNew in pygame-ce 2.3.1."
#define DOC_MIXER_GETSOUNDFONT "pygame.mixer.get_soundfont()\n\nget the soundfont for playing midi music\n\nget_soundfont() -> paths\n\nThis gets the soundfont filepaths as a string (each path is separated by a semi-colon)\nto be used in the playback of MID, MIDI, and KAR music file formats. If no\nsoundfont is specified, the return type is None.\n\nFunction get_soundfont() calls underlying SDL_mixer function\nMix_GetSoundFonts.\n\nNew in pygame-ce 2.3.1."
#define DOC_MIXER_GETBUSY "pygame.mixer.get_busy()\n\ntest if any sound is being mixed\n\nget_busy() -> bool\n\nReturns True if the mixer is busy mixing any channels. If the mixer is\nidle then this return False."
#define DOC_MIXER_GETSDLMIXERVERSION "pygame.mixer.get_sdl_mixer_version()\n\nget the mixer's SDL version\n\nget_sdl_mixer_version() -> (major, minor, patch)\n\nget_sdl_mixer_version(linked=True) -> (major, minor, patch)\n\nParameters\n\nlinked (bool) -- if True (default) the linked version number is\nreturned, otherwise the compiled version number is returned\n\nReturns\n\nthe mixer's SDL library version number (linked or compiled\ndepending on the linked parameter) as a tuple of 3 integers\n(major, minor, patch)\n\nReturn type\n\ntuple\n\nThe linked and compiled version numbers should be the same.\n\nNew in pygame 2.0.0."
#define DOC_MIXER_SOUND "pygame.mixer.Sound\n\nCreate a new Sound object from a file or buffer object\n\nSound(filename) -> Sound\n\nSound(file=filename) -> Sound\n\nSound(file=pathlib_path) -> Sound\n\nSound(buffer) -> Sound\n\nSound(buffer=buffer) -> Sound\n\nSound(object) -> Sound\n\nSound(file=object) -> Sound\n\nSound(array=object) -> Sound\n\nLoad a new sound buffer from a filename, a python file object or a readable\nbuffer object. Limited resampling will be performed to help the sample match\nthe initialize arguments for the mixer. A Unicode string can only be a file\npathname. A bytes object can be either a pathname or a buffer object.\nUse the 'file' or 'buffer' keywords to avoid ambiguity; otherwise Sound may\nguess wrong. If the array keyword is used, the object is expected to export\na new buffer interface (The object is checked for a buffer interface first.)\n\nThe Sound object represents actual sound sample data. Methods that change\nthe state of the Sound object will the all instances of the Sound playback.\nA Sound object also exports a new buffer interface.\n\nThe Sound can be loaded from an OGG audio file or from an uncompressed\nWAV.\n\nNote: The buffer will be copied internally, no data will be shared between\nit and the Sound object.\n\nFor now buffer and array support is consistent with sndarray.make_sound\nfor NumPy arrays, in that sample sign and byte order are ignored. This\nwill change, either by correctly handling sign and byte order, or by raising\nan exception when different. Also, source samples are truncated to fit the\naudio sample size. This will not change.\n\nNew in pygame 1.8: pygame.mixer.Sound(buffer)\n\nNew in pygame 1.9.2: pygame.mixer.Sound keyword arguments and array interface support\n\nNew in pygame 2.0.1: pathlib.Path support on Python 3.\n\nChanged in pygame-ce 2.5.2: This class is also available through the pygame.Sound\nalias.\n\n"
#define DOC_MIXER_SOUND_PLAY "play()\n\nbegin sound playback\n\nplay(loops=0, maxtime=0, fade_ms=0) -> Channel\n\nBegin playback of the Sound (i.e., on the computer's speakers) on an\navailable Channel. This will forcibly select a Channel, so playback may\ncut off a currently playing sound if necessary.\n\nThe loops argument controls how many times the sample will be repeated\nafter being played the first time. A value of 5 means that the sound will\nbe played once, then repeated five times, and so is played a total of six\ntimes. The default value (zero) means the Sound is not repeated, and so\nis only played once. If loops is set to -1 the Sound will loop\nindefinitely (though you can still call stop() to stop it).\n\nThe maxtime argument can be used to stop playback after a given number of\nmilliseconds.\n\nThe fade_ms argument will make the sound start playing at 0 volume and\nfade up to full volume over the time given. The sample may end before the\nfade-in is complete.\n\nThis returns the Channel object for the channel that was selected."
#define DOC_MIXER_SOUND_STOP "stop()\n\nstop sound playback\n\nstop() -> None\n\nThis will stop the playback of this Sound on any active Channels."
#define DOC_MIXER_SOUND_FADEOUT "fadeout()\n\nstop sound playback after fading out\n\nfadeout(time, /) -> None\n\nThis will stop playback of the sound after fading it out over the time\nargument in milliseconds. The Sound will fade and stop on all actively\nplaying channels."
#define DOC_MIXER_SOUND_SETVOLUME "set_volume()\n\nset the playback volume for this Sound\n\nset_volume(value, /) -> None\n\nThis will set the playback volume (loudness) for this Sound. This will\nimmediately affect the Sound if it is playing. It will also affect any\nfuture playback of this Sound.\n\nParameters\n\nvalue (float) -- volume in the range of 0.0 to 1.0 (inclusive)If value < 0.0, the volume will not be changed\n\nIf value > 1.0, the volume will be set to 1.0\n\nThe values are internally converted and kept as integer values in range [0, 128], which means\nthat get_volume() may return a different volume than it was set to. For example,\n\n>>> sound.set_volume(0.1)\n>>> sound.get_volume()\n0.09375\n\nThis is because when you set_volume(0.1), the volume is internally calculated like so\n\n>>> int(0.1 * 128)\n12\n\nThis means that some of the precision is lost, so when you retrieve it again using get_volume(),\nit is converted back to a float using that integer\n\n>>> 12 / 128\n0.09375"
#define DOC_MIXER_SOUND_GETVOLUME "get_volume()\n\nget the playback volume\n\nget_volume() -> value\n\nReturn a value from 0.0 to 1.0 (inclusive) representing the volume for this Sound.\n\nSee Sound.set_volume() for more information regarding the returned value"
#define DOC_MIXER_SOUND_GETNUMCHANNELS "get_num_channels()\n\ncount how many times this Sound is playing\n\nget_num_channels() -> count\n\nReturn the number of active channels this sound is playing on."
#define DOC_MIXER_SOUND_GETLENGTH "get_length()\n\nget the length of the Sound\n\nget_length() -> seconds\n\nReturn the length of this Sound in seconds."
#define DOC_MIXER_SOUND_GETRAW "get_raw()\n\nreturn a bytestring copy of the Sound samples.\n\nget_raw() -> bytes\n\nReturn a copy of the Sound object buffer as a bytes.\n\nNew in pygame 1.9.2."
#define DOC_MIXER_CHANNEL "pygame.mixer.Channel\n\nCreate a Channel object for controlling playback\n\nChannel(id) -> Channel\n\nReturn a Channel object for one of the current channels. The id must be a\nvalue from 0 up to, but not including, pygame.mixer.get_num_channels().\n\nThe Channel object can be used to get fine control over the playback of\nSounds. A channel can only playback a single Sound at time. Using channels\nis entirely optional since pygame can manage them by default.\n\nChanged in pygame-ce 2.1.4: This class is also available through the pygame.Channel\nalias.\n\nChanged in pygame-ce 2.4.0: It is now possible to create subclasses of pygame.mixer.Channel\n\n"
#define DOC_MIXER_CHANNEL_ID "id\n\nget the channel id for the Channel object\n\nid -> int\n\nThis simply returns the channel id used to create the Channel instance\nas a read-only attribute\n\n..versionadded:: 2.4.0"
#define DOC_MIXER_CHANNEL_PLAY "play()\n\nplay a Sound on a specific Channel\n\nplay(Sound, loops=0, maxtime=0, fade_ms=0) -> None\n\nThis will begin playback of a Sound on a specific Channel. If the Channel\nis currently playing any other Sound it will be stopped.\n\nThe loops argument has the same meaning as in Sound.play(): it is the\nnumber of times to repeat the sound after the first time. If it is 3, the\nsound will be played 4 times (the first time, then three more). If loops\nis -1 then the playback will repeat indefinitely.\n\nAs in Sound.play(), the maxtime argument can be used to stop playback\nof the Sound after a given number of milliseconds.\n\nAs in Sound.play(), the fade_ms argument can be used fade in the\nsound."
#define DOC_MIXER_CHANNEL_STOP "stop()\n\nstop playback on a Channel\n\nstop() -> None\n\nStop sound playback on a channel. After playback is stopped the channel\nbecomes available for new Sounds to play on it."
#define DOC_MIXER_CHANNEL_PAUSE "pause()\n\ntemporarily stop playback of a channel\n\npause() -> None\n\nTemporarily stop the playback of sound on a channel. It can be resumed at\na later time with Channel.unpause()"
#define DOC_MIXER_CHANNEL_UNPAUSE "unpause()\n\nresume pause playback of a channel\n\nunpause() -> None\n\nResume the playback on a paused channel."
#define DOC_MIXER_CHANNEL_FADEOUT "fadeout()\n\nstop playback after fading channel out\n\nfadeout(time, /) -> None\n\nStop playback of a channel after fading out the sound over the given time\nargument in milliseconds."
#define DOC_MIXER_CHANNEL_SETSOURCELOCATION "set_source_location()\n\nset the position of a playing channel\n\nset_source_location(angle, distance, /) -> None\n\nSet the position (angle, distance) of a playing channel.\n\nangle: Angle is in degrees.\n\ndistance: Range from 0 to 255.\n\nThis function currently fails and raises a\npygame.error when using 7.1 surround sound.\nBy default, the mixer module will use what the hardware is best\nsuited for, so this leads to hardware specific exceptions when using\nthis function.\n\nOne way of avoiding this is only using set_source_location()\nwith forced stereo. For example:\n\npygame.mixer.pre_init(\n   channels=2,\n   allowedchanges=pygame.AUDIO_ALLOW_FREQUENCY_CHANGE,\n)\npygame.init()\n\nNew in pygame-ce 2.3.0."
#define DOC_MIXER_CHANNEL_SETVOLUME "set_volume()\n\nset the volume of a playing channel\n\nset_volume(value, /) -> None\n\nset_volume(left, right, /) -> None\n\nSet the volume (loudness) of a playing sound. When a channel starts to\nplay its volume value is reset. This only affects the current sound. The\nvalue argument is in the range of 0.0 to 1.0 (inclusive).\n\nIf one argument is passed, it will be the volume of both speakers. If two\narguments are passed and the mixer is in stereo mode, the first argument\nwill be the volume of the left speaker and the second will be the volume\nof the right speaker. (If the second argument is None, the first\nargument will be the volume of both speakers.)\n\nIf the channel is playing a Sound on which set_volume() has also been\ncalled, both calls are taken into account. For example:\n\nsound = pygame.mixer.Sound(\"s.wav\")\nchannel = s.play()      # Sound plays at full volume by default\nsound.set_volume(0.9)   # Now plays at 90% of full volume.\nsound.set_volume(0.6)   # Now plays at 60% (previous value replaced).\nchannel.set_volume(0.5) # Now plays at 30% (0.6 * 0.5).\n\nSee Sound.set_volume() for more information regarding how the value is stored internally"
#define DOC_MIXER_CHANNEL_GETVOLUME "get_volume()\n\nget the volume of the playing channel\n\nget_volume() -> value\n\nReturn the volume of the channel for the current playing sound\nin the range of 0.0 to 1.0 (inclusive). This does\nnot take into account stereo separation used by\nChannel.set_volume(). The Sound object also has its own volume\nwhich is mixed with the channel.\n\nSee Sound.set_volume() for more information regarding the returned value"
#define DOC_MIXER_CHANNEL_GETBUSY "get_busy()\n\ncheck if the channel is active\n\nget_busy() -> bool\n\nReturns True if the channel is actively mixing sound. If the channel\nis idle this returns False."
#define DOC_MIXER_CHANNEL_GETSOUND "get_sound()\n\nget the currently playing Sound\n\nget_sound() -> Sound\n\nReturn the actual Sound object currently playing on this channel. If the\nchannel is idle None is returned."
#define DOC_MIXER_CHANNEL_QUEUE "queue()\n\nqueue a Sound object to follow the current\n\nqueue(sound, /) -> None\n\nWhen a Sound is queued on a Channel, it will begin playing immediately\nafter the current Sound is finished. Each channel can only have a single\nSound queued at a time. The queued Sound will only play if the current\nplayback finished automatically. It is cleared on any other call to\nChannel.stop() or Channel.play().\n\nIf there is no sound actively playing on the Channel then the Sound will\nbegin playing immediately."
#define DOC_MIXER_CHANNEL_GETQUEUE "get_queue()\n\nreturn any Sound that is queued\n\nget_queue() -> Sound\n\nIf a Sound is already queued on this channel it will be returned. Once\nthe queued sound begins playback it will no longer be on the queue."
#define DOC_MIXER_CHANNEL_SETENDEVENT "set_endevent()\n\nhave the channel send an event when playback stops\n\nset_endevent() -> None\n\nset_endevent(type, /) -> None\n\nWhen an endevent is set for a channel, it will send an event to the\npygame queue every time a sound finishes playing on that channel (not\njust the first time). Use pygame.event.get() to retrieve the endevent\nonce it's sent.\n\nNote that if you called Sound.play(n) or Channel.play(sound,n),\nthe end event is sent only once: after the sound has been played \"n+1\"\ntimes (see the documentation of Sound.play).\n\nIf Channel.stop() or Channel.play() is called while the sound was\nstill playing, the event will be posted immediately.\n\nThe type argument will be the event id sent to the queue. This can be any\nvalid event type, but a good choice would be a value between\npygame.locals.USEREVENT and pygame.locals.NUMEVENTS. If no type\nargument is given then the Channel will stop sending endevents."
#define DOC_MIXER_CHANNEL_GETENDEVENT "get_endevent()\n\nget the event a channel sends when playback stops\n\nget_endevent() -> type\n\nReturns the event type to be sent every time the Channel finishes\nplayback of a Sound. If there is no endevent the function returns\npygame.NOEVENT."
