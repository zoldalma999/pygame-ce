/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_TIME "pygame.time\n\n\n\nPygame module for monitoring time.\n\nProvides utilities for monitoring time, delaying time, and maintaining a\nconstant frame rate.\nTimes in pygame-ce are represented in milliseconds (1/1000 of a second)."
#define DOC_TIME_GETTICKS "pygame.time.get_ticks()\n\nGet the time in milliseconds.\n\nget_ticks() -> int\n\nReturn the number of milliseconds since pygame.init() was called. Before\npygame is initialized this will always be 0."
#define DOC_TIME_WAIT "pygame.time.wait()\n\nPause the program for an amount of time.\n\nwait(milliseconds, /) -> int\n\nWill pause for a given number of milliseconds. This function sleeps the\nprocess to share the processor with other programs. A program that waits for\neven a few milliseconds will consume very little processor time. It is\nslightly less accurate than the pygame.time.delay() function.\n\nThis returns the actual number of milliseconds used."
#define DOC_TIME_DELAY "pygame.time.delay()\n\nPause the program for an amount of time.\n\ndelay(milliseconds, /) -> int\n\nWill pause for a given number of milliseconds. This function will use the\nprocessor (rather than sleeping) in order to make the delay more accurate\nthan pygame.time.wait().\n\nThis returns the actual number of milliseconds used."
#define DOC_TIME_SETTIMER "pygame.time.set_timer()\n\nRepeatedly create an event on the event queue.\n\nset_timer(event, millis, loops=0) -> None\n\nSet an event to appear on the event queue every given number of milliseconds.\nThe first event will not appear until the amount of time has passed.\n\nThe event attribute can be a pygame.event.Event object or an integer\ntype that denotes an event.\n\nloops is an integer that denotes the number of events posted. If 0 (default)\nthen the events will keep getting posted, unless explicitly stopped.\n\nTo disable the timer for such an event, call the function again with the same\nevent argument with millis argument set to 0.\n\nIt is also worth mentioning that a particular event type can only be put on a\ntimer once. In other words, there cannot be two timers for the same event type.\nSetting an event timer for a particular event discards the old one for that\nevent type.\n\nWhen this function is called with an Event object, the event(s) received\non the event queue will be a shallow copy; the dict attribute of the event\nobject passed as an argument and the dict attributes of the event objects\nreceived on timer will be references to the same dict object in memory.\nModifications on one dict can affect another, use deepcopy operations on the\ndict object if you don't want this behaviour.\nHowever, calling this function with an integer event type would place event objects\non the queue that don't have a common dict reference.\n\nloops replaces the once argument, and this does not break backward\ncompatibility.\n\nNew in pygame 2.0.0.dev3: once argument added.\n\nChanged in pygame 2.0.1: event argument supports pygame.event.Event object\n\nNew in pygame 2.0.1: added loops argument to replace once argument"
#define DOC_TIME_CLOCK "pygame.time.Clock\n\nCreate an object to help track time.\n\nClock() -> Clock\n\nCreates a new Clock object that can be used to track an amount of time. The\nclock also provides several functions to help control a game's framerate.\n\nChanged in pygame-ce 2.1.4: This class is also available through the pygame.Clock\nalias.\n\n"
#define DOC_TIME_CLOCK_TICK "tick()\n\nUpdate the clock.\n\ntick(framerate=0, /) -> int\n\nThis method should be called once per frame. It will compute how many\nmilliseconds have passed since the previous call.\n\nIf you pass the optional framerate argument the function will delay to\nkeep the game running slower than the given ticks per second. This can be\nused to help limit the runtime speed of a game. By calling\nClock.tick(40) once per frame, the program will never run at more\nthan 40 frames per second.\n\nNote that this function uses SDL_Delay function which is not accurate on\nevery platform, but does not use much CPU. Use tick_busy_loop if you want\nan accurate timer, and don't mind chewing CPU."
#define DOC_TIME_CLOCK_TICKBUSYLOOP "tick_busy_loop()\n\nUpdate the clock.\n\ntick_busy_loop(framerate=0, /) -> int\n\nThis method should be called once per frame. It will compute how many\nmilliseconds have passed since the previous call.\n\nIf you pass the optional framerate argument the function will delay to\nkeep the game running slower than the given ticks per second. This can be\nused to help limit the runtime speed of a game. By calling\nClock.tick_busy_loop(40) once per frame, the program will never run at\nmore than 40 frames per second.\n\nNote that this function uses pygame.time.delay(), which uses lots\nof CPU in a busy loop to make sure that timing is more accurate.\n\nNew in pygame 1.8."
#define DOC_TIME_CLOCK_GETTIME "get_time()\n\nTime used in the previous tick.\n\nget_time() -> int\n\nThe number of milliseconds that passed between the previous two calls to\nClock.tick()."
#define DOC_TIME_CLOCK_GETRAWTIME "get_rawtime()\n\nActual time used in the previous tick.\n\nget_rawtime() -> int\n\nSimilar to Clock.get_time(), but does not include any time used\nwhile Clock.tick() was delaying to limit the framerate."
#define DOC_TIME_CLOCK_GETFPS "get_fps()\n\nCompute the clock framerate.\n\nget_fps() -> float\n\nCompute your game's framerate (in frames per second). It is computed by\naveraging the last ten calls to Clock.tick()."
