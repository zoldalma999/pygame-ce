/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_CAMERA "pygame.camera\n\n\n\npygame module for camera use\n\nPygame currently supports Linux (V4L2) and Windows (MSMF) cameras natively,\nwith wider platform support available via an integrated OpenCV backend.\n\nNew in pygame 2.0.2: Windows native camera support\n\nNew in pygame 2.0.3: New OpenCV backends\n\nChanged in pygame-ce 2.3.0: Removed deprecated vidcapture backend\n\nEXPERIMENTAL!: This API may change or disappear in later pygame releases. If\nyou use this, your code will very likely break with the next pygame release.\n\nThe Bayer to RGB function is based on:\n\nSonix SN9C101 based webcam basic I/F routines\nCopyright (C) 2004 Takafumi Mizuno <taka-qce@ls-a.jp>\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\nOR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\nLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\nOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nNew in pygame 1.9.0."
#define DOC_CAMERA_INIT "pygame.camera.init()\n\nModule init\n\ninit(backend = None) -> None\n\nThis function starts up the camera module, choosing the best webcam backend\nit can find for your system. This is not guaranteed to succeed, and may even\nattempt to import third party modules, like OpenCV. If you want to\noverride its backend choice, you can call pass the name of the backend you\nwant into this function. More about backends in\nget_backends().\n\nChanged in pygame 2.0.3: Option to explicitly select backend"
#define DOC_CAMERA_GETBACKENDS "pygame.camera.get_backends()\n\nGet the backends supported on this system\n\nget_backends() -> [str]\n\nThis function returns every backend it thinks has a possibility of working\non your system, in order of priority.\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/camera.rst:74: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\npygame.camera Backends:\n\nBackend           OS        Description\n---------------------------------------------------------------------------------\n_camera (MSMF)    Windows   Builtin, works on Windows 8+ Python3\n_camera (V4L2)    Linux     Builtin\nOpenCV            Any       Uses `opencv-python` module, can't enumerate cameras\nOpenCV-Mac        Mac       Same as OpenCV, but has camera enumeration\n\nThere are two main differences among backends.\n\nThe _camera backends are built in to pygame itself, and require no third\nparty imports. All the other backends do. For the OpenCV backend,\nthe module will need to be installed on your system.\n\nThe other big difference is \"camera enumeration.\" Some backends don't have\na way to list out camera names, or even the number of cameras on the\nsystem. In these cases, list_cameras() will return\nsomething like [0]. If you know you have multiple cameras on the\nsystem, these backend ports will pass through a \"camera index number\"\nthrough if you use that as the device parameter.\n\nNew in pygame 2.0.3."
#define DOC_CAMERA_COLORSPACE "pygame.camera.colorspace()\n\nSurface colorspace conversion\n\ncolorspace(surface, format, dest_surface = None, /) -> Surface\n\nAllows for conversion from \"RGB\" to a destination colorspace of \"HSV\" or\n\"YUV\". The source and destination surfaces must be the same size and pixel\ndepth. This is useful for computer vision on devices with limited processing\npower. Capture as small of an image as possible, transform.scale() it\neven smaller, and then convert the colorspace to YUV or HSV before\ndoing any processing on it."
#define DOC_CAMERA_LISTCAMERAS "pygame.camera.list_cameras()\n\nreturns a list of available cameras\n\nlist_cameras() -> [cameras]\n\nChecks the computer for available cameras and returns a list of strings of\ncamera names, ready to be fed into pygame.camera.Camera.\n\nIf the camera backend doesn't support webcam enumeration, this will return\nsomething like [0]. See get_backends() for much more\ninformation."
#define DOC_CAMERA_CAMERA "pygame.camera.Camera\n\nload a camera\n\nCamera(device, (width, height), format) -> Camera\n\nLoads a camera. On Linux, the device is typically something like\n\"/dev/video0\". Default width and height are 640 by 480.\nFormat is the desired colorspace of the output.\nThis is useful for computer vision purposes. The default is\nRGB. The following are supported:\n\nRGB - Red, Green, Blue\n\nYUV - Luma, Blue Chrominance, Red Chrominance\n\nHSV - Hue, Saturation, Value\n\n"
#define DOC_CAMERA_CAMERA_START "start()\n\nopens, initializes, and starts capturing\n\nstart() -> None\n\nOpens the camera device, attempts to initialize it, and begins recording\nimages to a buffer. The camera must be started before any of the below\nfunctions can be used."
#define DOC_CAMERA_CAMERA_STOP "stop()\n\nstops, uninitializes, and closes the camera\n\nstop() -> None\n\nStops recording, uninitializes the camera, and closes it. Once a camera\nis stopped, the below functions cannot be used until it is started again."
#define DOC_CAMERA_CAMERA_GETCONTROLS "get_controls()\n\ngets current values of user controls\n\nget_controls() -> (hflip = bool, vflip = bool, brightness)\n\nIf the camera supports it, get_controls will return the current settings\nfor horizontal and vertical image flip as bools and brightness as an int.\nIf unsupported, it will return the default values of (0, 0, 0). Note that\nthe return values here may be different than those returned by\nset_controls, though these are more likely to be correct."
#define DOC_CAMERA_CAMERA_SETCONTROLS "set_controls()\n\nchanges camera settings if supported by the camera\n\nset_controls(hflip = bool, vflip = bool, brightness) -> (hflip = bool, vflip = bool, brightness)\n\nAllows you to change camera settings if the camera supports it. The\nreturn values will be the input values if the camera claims it succeeded\nor the values previously in use if not. Each argument is optional, and\nthe desired one can be chosen by supplying the keyword, like hflip. Note\nthat the actual settings being used by the camera may not be the same as\nthose returned by set_controls. On Windows, hflip and vflip are\nimplemented by pygame, not by the Camera, so they should always work, but\nbrightness is unsupported."
#define DOC_CAMERA_CAMERA_GETSIZE "get_size()\n\nreturns the dimensions of the images being recorded\n\nget_size() -> (width, height)\n\nReturns the current dimensions of the images being captured by the\ncamera. This will return the actual size, which may be different than the\none specified during initialization if the camera did not support that\nsize."
#define DOC_CAMERA_CAMERA_QUERYIMAGE "query_image()\n\nchecks if a frame is ready\n\nquery_image() -> bool\n\nIf an image is ready to get, it returns true. Otherwise it returns false.\nNote that some webcams will always return False and will only queue a\nframe when called with a blocking function like get_image().\nOn Windows (MSMF), and the  OpenCV backends, query_image()\nshould be reliable, though. This is useful to separate the framerate of\nthe game from that of the camera without having to use threading."
#define DOC_CAMERA_CAMERA_GETIMAGE "get_image()\n\ncaptures an image as a Surface\n\nget_image(Surface = None, /) -> Surface\n\nPulls an image off of the buffer as an RGB Surface. It can optionally\nreuse an existing Surface to save time. The bit-depth of the surface is\n24 bits on Linux, 32 bits on Windows, or the same as the optionally\nsupplied Surface."
#define DOC_CAMERA_CAMERA_GETRAW "get_raw()\n\nreturns an unmodified image as bytes\n\nget_raw() -> bytes\n\nGets an image from a camera as a string in the native pixelformat of the\ncamera. Useful for integration with other libraries. This returns a\nbytes object"
