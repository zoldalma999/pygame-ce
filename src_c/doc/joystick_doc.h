/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_JOYSTICK "pygame.joystick\n\n\n\nPygame module for interacting with joysticks, gamepads, and trackballs.\n\nThe joystick module manages the joystick devices on a computer.\nJoystick devices include trackballs and video-game-style\ngamepads, and the module allows the use of multiple buttons and \"hats\".\nComputers may manage multiple joysticks at a time.\n\nEach instance of the Joystick class represents one gaming device plugged\ninto the computer. If a gaming pad has multiple joysticks on it, then the\njoystick object can actually represent multiple joysticks on that single\ngame device.\n\nFor a quick way to initialise the joystick module and get a list of Joystick instances\nuse the following code:\n\npygame.joystick.init()\njoysticks = [pygame.joystick.Joystick(x) for x in range(pygame.joystick.get_count())]\n\nThe following event types will be generated by the joysticks\n\nJOYAXISMOTION JOYBALLMOTION JOYBUTTONDOWN JOYBUTTONUP JOYHATMOTION\n\nAnd in pygame 2, which supports hotplugging:\n\nJOYDEVICEADDED JOYDEVICEREMOVED\n\nNote that in pygame 2, joysticks events use a unique \"instance ID\". The device index\npassed in the constructor to a Joystick object is not unique after devices have\nbeen added and removed. You must call Joystick.get_instance_id() to find\nthe instance ID that was assigned to a Joystick on opening.\n\nThe event queue needs to be pumped frequently for some of the methods to work.\nSo call one of pygame.event.get, pygame.event.wait, or pygame.event.pump regularly.\n\nTo be able to get joystick events and update the joystick objects while the window\nis not in focus, you may set the SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS environment\nvariable. See environment variables for more details.\n\njoystick module example\n\nExample code for joystick module.\n\nimport pygame\n\npygame.init()\n\n\ndef indent(text, indentation_level=0):\n    return (\"    \" * indentation_level) + text\n\n\ndef main():\n    # Set the size of the screen (width, height), and name the window.\n    size = (500, 700)\n    screen = pygame.display.set_mode(size)\n    pygame.display.set_caption(\"Joystick example\")\n\n    # Used to manage how fast the screen updates.\n    clock = pygame.Clock()\n\n    # Get ready to print.\n    font = pygame.font.SysFont(None, 25)\n    wraplength = size[0] - 20\n\n    # This dict can be left as-is, since pygame-ce will generate a\n    # pygame.JOYDEVICEADDED event for every joystick connected\n    # at the start of the program.\n    joysticks = {}\n\n    done = False\n    while not done:\n        # Event processing step.\n        # Possible joystick events: JOYAXISMOTION, JOYBALLMOTION, JOYBUTTONDOWN,\n        # JOYBUTTONUP, JOYHATMOTION, JOYDEVICEADDED, JOYDEVICEREMOVED\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                done = True  # Flag that we are done so we exit this loop.\n\n            if event.type == pygame.JOYBUTTONDOWN:\n                print(\"Joystick button pressed.\")\n                if event.button == 0:\n                    joystick = joysticks[event.instance_id]\n                    if joystick.rumble(0, 0.7, 500):\n                        print(f\"Rumble effect played on joystick {event.instance_id}\")\n\n            if event.type == pygame.JOYBUTTONUP:\n                print(\"Joystick button released.\")\n\n            # Handle hotplugging\n            if event.type == pygame.JOYDEVICEADDED:\n                # This event will be generated when the program starts for every\n                # joystick, filling up the list without needing to create them manually.\n                joy = pygame.joystick.Joystick(event.device_index)\n                joysticks[joy.get_instance_id()] = joy\n                print(f\"Joystick {joy.get_instance_id()} connected\")\n\n            if event.type == pygame.JOYDEVICEREMOVED:\n                if event.instance_id in joysticks:\n                    del joysticks[event.instance_id]\n                    print(f\"Joystick {event.instance_id} disconnected\")\n                else:\n                    print(\n                        f\"Tried to disconnect Joystick {event.instance_id}, \"\n                        \"but couldn't find it in the joystick list\"\n                    )\n\n        # Drawing step\n        # First, clear the screen to white. Don't put other drawing commands\n        # above this, or they will be erased with this command.\n        screen.fill((255, 255, 255))\n        indentation = 0\n        lines = []\n\n        # Get count of joysticks.\n        joystick_count = pygame.joystick.get_count()\n        lines.append(indent(f\"Number of joysticks: {joystick_count}\", indentation))\n        indentation += 1\n\n        # For each joystick:\n        for joystick in joysticks.values():\n            jid = joystick.get_instance_id()\n\n            lines.append(indent(f\"Joystick {jid}\", indentation))\n            indentation += 1\n\n            # Get the name from the OS for the controller/joystick.\n            name = joystick.get_name()\n            lines.append(indent(f\"Joystick name: {name}\", indentation))\n\n            guid = joystick.get_guid()\n            lines.append(indent(f\"GUID: {guid}\", indentation))\n\n            power_level = joystick.get_power_level()\n            lines.append(indent(f\"Joystick's power level: {power_level}\", indentation))\n\n            # Usually axis run in pairs, up/down for one, and left/right for\n            # the other. Triggers count as axes.\n            axes = joystick.get_numaxes()\n            lines.append(indent(f\"Number of axes: {axes}\", indentation))\n            indentation += 1\n\n            for i in range(axes):\n                axis = joystick.get_axis(i)\n                lines.append(indent(f\"Axis {i} value: {axis:>6.3f}\", indentation))\n            indentation -= 1\n\n            buttons = joystick.get_numbuttons()\n            lines.append(indent(f\"Number of buttons: {buttons}\", indentation))\n            indentation += 1\n\n            for i in range(buttons):\n                button = joystick.get_button(i)\n                lines.append(indent(f\"Button {i:>2} value: {button}\", indentation))\n            indentation -= 1\n\n            hats = joystick.get_numhats()\n            lines.append(indent(f\"Number of hats: {hats}\", indentation))\n            indentation += 1\n\n            # Hat position. All or nothing for direction, not a float like\n            # get_axis(). Position is a tuple of int values (x, y).\n            for i in range(hats):\n                hat = joystick.get_hat(i)\n                lines.append(indent(f\"Hat {i} value: {str(hat)}\", indentation))\n            indentation -= 2\n\n        # draw the accumulated text\n        screen.blit(\n            font.render(\"\\n\".join(lines), True, \"black\", \"white\", wraplength), (10, 10)\n        )\n\n        # Go ahead and update the screen with what we've drawn.\n        pygame.display.flip()\n\n        # Limit to 30 frames per second.\n        clock.tick(30)\n\n\nif __name__ == \"__main__\":\n    main()\n    # If you forget this line, the program will 'hang'\n    # on exit if running from IDLE.\n    pygame.quit()"
#define DOC_JOYSTICK_INIT "pygame.joystick.init()\n\nInitialize the joystick module.\n\ninit() -> None\n\nThis function is called automatically by pygame.init().\n\nIt initializes the joystick module. The module must be initialized before any\nother functions will work.\n\nIt is safe to call this function more than once."
#define DOC_JOYSTICK_QUIT "pygame.joystick.quit()\n\nUninitialize the joystick module.\n\nquit() -> None\n\nUninitialize the joystick module. After you call this any existing joystick\nobjects will no longer work.\n\nIt is safe to call this function more than once."
#define DOC_JOYSTICK_GETINIT "pygame.joystick.get_init()\n\nReturns True if the joystick module is initialized.\n\nget_init() -> bool\n\nTest if the pygame.joystick.init() function has been called."
#define DOC_JOYSTICK_GETCOUNT "pygame.joystick.get_count()\n\nReturns the number of joysticks.\n\nget_count() -> count\n\nReturn the number of joystick devices on the system. The count will be 0\nif there are no joysticks on the system.\n\nWhen you create Joystick objects using Joystick(id), you pass an integer\nthat must be lower than this count."
#define DOC_JOYSTICK_JOYSTICK "pygame.joystick.Joystick\n\nCreate a new Joystick object.\n\nJoystick(id, /) -> Joystick\n\nCreate a new joystick to access a physical device. The id argument must be a\nvalue from 0 to pygame.joystick.get_count() - 1.\n\nJoysticks are initialised on creation and are shut down when deallocated.\nOnce the device is initialized the pygame event queue will start receiving\nevents about its input.\n\nChanged in pygame 2.0.0: Joystick objects are now opened immediately on creation.\n\nChanged in pygame-ce 2.1.4: This class is also available through the pygame.Joystick\nalias.\n\n"
#define DOC_JOYSTICK_JOYSTICK_INIT "init()\n\ninitialize the Joystick\n\ninit() -> None\n\nInitialize the joystick, if it has been closed. It is safe to call this\neven if the joystick is already initialized.\n\nDeprecated since pygame 2.0.0: In future it will not be possible to reinitialise a closed Joystick\nobject."
#define DOC_JOYSTICK_JOYSTICK_QUIT "quit()\n\nuninitialize the Joystick\n\nquit() -> None\n\nClose a Joystick object. After this the pygame event queue will no longer\nreceive events from the device.\n\nIt is safe to call this more than once."
#define DOC_JOYSTICK_JOYSTICK_GETINIT "get_init()\n\ncheck if the Joystick is initialized\n\nget_init() -> bool\n\nReturn True if the Joystick object is currently initialised."
#define DOC_JOYSTICK_JOYSTICK_GETID "get_id()\n\nget the device index (deprecated)\n\nget_id() -> int\n\nReturns the original device index for this device. This is the same\nvalue that was passed to the Joystick() constructor. This method can\nsafely be called while the Joystick is not initialized.\n\nDeprecated since pygame 2.0.0: The original device index is not useful in pygame 2. Use\nget_instance_id() instead."
#define DOC_JOYSTICK_JOYSTICK_GETINSTANCEID "get_instance_id() -> int\n\nget the joystick instance id\n\nget_instance_id() -> int\n\nGet the joystick instance ID. This matches the instance_id field\nthat is given in joystick events.\n\nNew in pygame 2.0.0dev11."
#define DOC_JOYSTICK_JOYSTICK_GETGUID "get_guid() -> str\n\nget the joystick GUID\n\nget_guid() -> str\n\nGet the GUID string. This identifies the exact hardware of the joystick\ndevice.\n\nNew in pygame 2.0.0dev11."
#define DOC_JOYSTICK_JOYSTICK_GETPOWERLEVEL "get_power_level() -> str\n\nget the approximate power status of the device\n\nget_power_level() -> str\n\nGet a string giving the power status of the device.\n\nOne of: empty, low, medium, full, wired, max, or\nunknown.\n\nNew in pygame 2.0.0dev11."
#define DOC_JOYSTICK_JOYSTICK_GETNAME "get_name()\n\nget the Joystick system name\n\nget_name() -> string\n\nReturns the system name for this joystick device. It is unknown what name\nthe system will give to the Joystick, but it should be a unique name that\nidentifies the device. This method can safely be called while the\nJoystick is not initialized."
#define DOC_JOYSTICK_JOYSTICK_GETNUMAXES "get_numaxes()\n\nget the number of axes on a Joystick\n\nget_numaxes() -> int\n\nReturns the number of input axes are on a Joystick. There will usually be\ntwo for the position. Controls like rudders and throttles are treated as\nadditional axes.\n\nThe pygame.JOYAXISMOTION events will be in the range from -1.0\nto 1.0. A value of 0.0 means the axis is centered. Gamepad devices\nwill usually be -1, 0, or 1 with no values in between. Older\nanalog joystick axes will not always use the full -1 to 1 range,\nand the centered value will be some area around 0.\n\nAnalog joysticks usually have a bit of noise in their axis, which will\ngenerate a lot of rapid small motion events."
#define DOC_JOYSTICK_JOYSTICK_GETAXIS "get_axis()\n\nget the current position of an axis\n\nget_axis(axis_number, /) -> float\n\nReturns the current position of a joystick axis. The value will range\nfrom -1 to 1 with a value of 0 being centered. You may want\nto take into account some tolerance to handle jitter, and joystick drift\nmay keep the joystick from centering at 0 or using the full range of\nposition values.\n\nThe axis number must be an integer from 0 to get_numaxes() - 1.\n\nWhen using gamepads both the control sticks and the analog triggers are\nusually reported as axes."
#define DOC_JOYSTICK_JOYSTICK_GETNUMBALLS "get_numballs()\n\nget the number of trackballs on a Joystick\n\nget_numballs() -> int\n\nReturns the number of trackball devices on a Joystick. These devices work\nsimilar to a mouse but they have no absolute position; they only have\nrelative amounts of movement.\n\nThe pygame.JOYBALLMOTION event will be sent when the trackball is\nrolled. It will report the amount of movement on the trackball."
#define DOC_JOYSTICK_JOYSTICK_GETBALL "get_ball()\n\nget the relative position of a trackball\n\nget_ball(ball_number, /) -> x, y\n\nReturns the relative movement of a joystick button. The value is a x, y\npair holding the relative movement since the last call to get_ball.\n\nThe ball number must be an integer from 0 to get_numballs() - 1."
#define DOC_JOYSTICK_JOYSTICK_GETNUMBUTTONS "get_numbuttons()\n\nget the number of buttons on a Joystick\n\nget_numbuttons() -> int\n\nReturns the number of pushable buttons on the joystick. These buttons\nhave a boolean (on or off) state.\n\nButtons generate a pygame.JOYBUTTONDOWN and pygame.JOYBUTTONUP\nevent when they are pressed and released."
#define DOC_JOYSTICK_JOYSTICK_GETBUTTON "get_button()\n\nget the current button state\n\nget_button(button, /) -> bool\n\nReturns the current state of a joystick button."
#define DOC_JOYSTICK_JOYSTICK_GETNUMHATS "get_numhats()\n\nget the number of hat controls on a Joystick\n\nget_numhats() -> int\n\nReturns the number of joystick hats on a Joystick. Hat devices are like\nminiature digital joysticks on a joystick. Each hat has two axes of\ninput.\n\nThe pygame.JOYHATMOTION event is generated when the hat changes\nposition. The position attribute for the event contains a pair of\nvalues that are either -1, 0, or 1. A position of (0, 0)\nmeans the hat is centered."
#define DOC_JOYSTICK_JOYSTICK_GETHAT "get_hat()\n\nget the position of a joystick hat\n\nget_hat(hat_number, /) -> x, y\n\nReturns the current position of a position hat. The position is given as\ntwo values representing the x and y position for the hat. (0, 0)\nmeans centered. A value of -1 means left/down and a value of 1 means\nright/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means\nup; (1, 1) means upper-right; etc.\n\nThis value is digital, i.e., each coordinate can be -1, 0 or 1\nbut never in-between.\n\nThe hat number must be between 0 and get_numhats() - 1."
#define DOC_JOYSTICK_JOYSTICK_RUMBLE "rumble()\n\nStart a rumbling effect\n\nrumble(low_frequency, high_frequency, duration) -> bool\n\nStart a rumble effect on the joystick, with the specified strength ranging\nfrom 0 to 1. Duration is length of the effect, in ms. Setting the duration\nto 0 will play the effect until another one overwrites it or\nJoystick.stop_rumble() is called. If an effect is already\nplaying, then it will be overwritten.\n\nReturns True if the rumble was played successfully or False if the\njoystick does not support it.\n\nNew in pygame 2.0.2."
#define DOC_JOYSTICK_JOYSTICK_STOPRUMBLE "stop_rumble()\n\nStop any rumble effect playing\n\nstop_rumble() -> None\n\nStops any rumble effect playing on the joystick. See\nJoystick.rumble() for more information.\n\nNew in pygame 2.0.2."
