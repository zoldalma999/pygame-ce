/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_PIXELARRAY "pygame.PixelArray\n\npygame object for direct pixel access of surfaces\n\nPixelArray(Surface) -> PixelArray\n\nThe PixelArray wraps a Surface and provides direct access to the\nsurface's pixels. A pixel array can be one or two dimensional.\nA two dimensional array, like its surface, is indexed [column, row].\nPixel arrays support slicing, both for returning a subarray or\nfor assignment. A pixel array sliced on a single column or row\nreturns a one dimensional pixel array. Arithmetic and other operations\nare not supported. A pixel array can be safely assigned to itself.\nFinally, pixel arrays export an array struct interface, allowing\nthem to interact with pygame.pixelcopy methods and NumPy\narrays.\n\nA PixelArray pixel item can be assigned a raw integer values, a\npygame.Color instance, or a (r, g, b[, a]) tuple.\n\npxarray[x, y] = 0xFF00FF\npxarray[x, y] = pygame.Color(255, 0, 255)\npxarray[x, y] = (255, 0, 255)\n\nHowever, only a pixel's integer value is returned. So, to compare a pixel\nto a particular color the color needs to be first mapped using\nthe Surface.map_rgb() method of the Surface object for which the\nPixelArray was created.\n\npxarray = pygame.PixelArray(surface)\n# Check, if the first pixel at the topleft corner is blue\nif pxarray[0, 0] == surface.map_rgb((0, 0, 255)):\n    ...\n\nWhen assigning to a range of pixels, a non tuple sequence of colors or\na PixelArray can be used as the value. For a sequence, the length must\nmatch the PixelArray width.\n\npxarray[a:b] = 0xFF00FF                   # set all pixels to 0xFF00FF\npxarray[a:b] = (0xFF00FF, 0xAACCEE, ... ) # first pixel = 0xFF00FF,\n                                          # second pixel  = 0xAACCEE, ...\npxarray[a:b] = [(255, 0, 255), (170, 204, 238), ...] # same as above\npxarray[a:b] = [(255, 0, 255), 0xAACCEE, ...]        # same as above\npxarray[a:b] = otherarray[x:y]            # slice sizes must match\n\nFor PixelArray assignment, if the right hand side array has a row length\nof 1, then the column is broadcast over the target array's rows. An\narray of height 1 is broadcast over the target's columns, and is equivalent\nto assigning a 1D PixelArray.\n\nSubscript slices can also be used to assign to a rectangular subview of\nthe target PixelArray.\n\n# Create some new PixelArray objects providing a different view\n# of the original array/surface.\nnewarray = pxarray[2:4, 3:5]\notherarray = pxarray[::2, ::2]\n\nSubscript slices can also be used to do fast rectangular pixel manipulations\ninstead of iterating over the x or y axis. The\n\npxarray[::2, :] = (0, 0, 0)               # Make even columns black.\npxarray[::2] = (0, 0, 0)                  # Same as [::2, :]\n\nDuring its lifetime, the PixelArray locks the surface, thus you explicitly\nhave to close() it once it's not used any more and the surface should perform\noperations in the same scope. It is best to use it as a context manager\nusing the with PixelArray(surf) as pixel_array: style. So it works on pypy too.\n\nA simple : slice index for the column can be omitted.\n\npxarray[::2, ...] = (0, 0, 0)             # Same as pxarray[::2, :]\npxarray[...] = (255, 0, 0)                # Same as pxarray[:]\n\nA note about PixelArray to PixelArray assignment, for arrays with an\nitem size of 3 (created from 24 bit surfaces) pixel values are translated\nfrom the source to the destinations format. The red, green, and blue\ncolor elements of each pixel are shifted to match the format of the\ntarget surface. For all other pixel sizes no such remapping occurs.\nThis should change in later pygame releases, where format conversions\nare performed for all pixel sizes. To avoid code breakage when full mapped\ncopying is implemented it is suggested PixelArray to PixelArray copies be\nonly between surfaces of identical format.\n\nNew in pygame 1.9.4: close() method was added. For explicitly cleaning up.\n\nbeing able to use PixelArray as a context manager for cleanup.\n\nboth of these are useful for when working without reference counting (pypy).\n\nNew in pygame 1.9.2: array struct interface\n\ntranspose method\n\nbroadcasting for a length 1 dimension\n\nChanged in pygame 1.9.2: A 2D PixelArray can have a length 1 dimension.\nOnly an integer index on a 2D PixelArray returns a 1D array.\n\nFor assignment, a tuple can only be a color. Any other sequence type\nis a sequence of colors.\n\n"
#define DOC_PIXELARRAY_SURFACE "surface\n\nGets the Surface the PixelArray uses.\n\nsurface -> Surface\n\nThe Surface the PixelArray was created for."
#define DOC_PIXELARRAY_ITEMSIZE "itemsize\n\nReturns the byte size of a pixel array item\n\nitemsize -> int\n\nThis is the same as Surface.get_bytesize() for the\npixel array's surface.\n\nNew in pygame 1.9.2."
#define DOC_PIXELARRAY_NDIM "ndim\n\nReturns the number of dimensions.\n\nndim -> int\n\nA pixel array can be 1 or 2 dimensional.\n\nNew in pygame 1.9.2."
#define DOC_PIXELARRAY_SHAPE "shape\n\nReturns the array size.\n\nshape -> tuple of int's\n\nA tuple or length ndim giving the length of each\ndimension. Analogous to Surface.get_size().\n\nNew in pygame 1.9.2."
#define DOC_PIXELARRAY_STRIDES "strides\n\nReturns byte offsets for each array dimension.\n\nstrides -> tuple of int's\n\nA tuple or length ndim byte counts. When a stride is\nmultiplied by the corresponding index it gives the offset\nof that index from the start of the array. A stride is negative\nfor an array that has is inverted (has a negative step).\n\nNew in pygame 1.9.2."
#define DOC_PIXELARRAY_MAKESURFACE "make_surface()\n\nCreates a new Surface from the current PixelArray.\n\nmake_surface() -> Surface\n\nCreates a new Surface from the current PixelArray. Depending on the\ncurrent PixelArray the size, pixel order etc. will be different from the\noriginal Surface.\n\n# Create a new surface flipped around the vertical axis.\nsf = pxarray[:,::-1].make_surface ()\n\nNew in pygame 1.8.1."
#define DOC_PIXELARRAY_REPLACE "replace()\n\nReplaces the passed color in the PixelArray with another one.\n\nreplace(color, repcolor, distance=0, weights=(0.299, 0.587, 0.114)) -> None\n\nReplaces the pixels with the passed color in the PixelArray by changing\nthem them to the passed replacement color.\n\nIt uses a simple weighted Euclidean distance formula to calculate the\ndistance between the colors. The distance space ranges from 0.0 to 1.0\nand is used as threshold for the color detection. This causes the\nreplacement to take pixels with a similar, but not exactly identical\ncolor, into account as well.\n\nThis is an in place operation that directly affects the pixels of the\nPixelArray.\n\nNew in pygame 1.8.1."
#define DOC_PIXELARRAY_EXTRACT "extract()\n\nExtracts the passed color from the PixelArray.\n\nextract(color, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray\n\nExtracts the passed color by changing all matching pixels to white, while\nnon-matching pixels are changed to black. This returns a new PixelArray\nwith the black/white color mask.\n\nIt uses a simple weighted Euclidean distance formula to calculate the\ndistance between the colors. The distance space ranges from 0.0 to 1.0\nand is used as threshold for the color detection. This causes the\nextraction to take pixels with a similar, but not exactly identical\ncolor, into account as well.\n\nNew in pygame 1.8.1."
#define DOC_PIXELARRAY_COMPARE "compare()\n\nCompares the PixelArray with another one.\n\ncompare(array, distance=0, weights=(0.299, 0.587, 0.114)) -> PixelArray\n\nCompares the contents of the PixelArray with those from the passed in\nPixelArray. It returns a new PixelArray with a black/white color mask\nthat indicates the differences (black) of both arrays. Both PixelArray\nobjects must have identical bit depths and dimensions.\n\nIt uses a simple weighted Euclidean distance formula to calculate the\ndistance between the colors. The distance space ranges from 0.0 to 1.0\nand is used as a threshold for the color detection. This causes the\ncomparison to mark pixels with a similar, but not exactly identical\ncolor, as white.\n\nNew in pygame 1.8.1."
#define DOC_PIXELARRAY_TRANSPOSE "transpose()\n\nExchanges the x and y axis.\n\ntranspose() -> PixelArray\n\nThis method returns a new view of the pixel array with the rows and\ncolumns swapped. So for a (w, h) sized array a (h, w) slice is returned.\nIf an array is one dimensional, then a length 1 x dimension is added,\nresulting in a 2D pixel array.\n\nNew in pygame 1.9.2."
#define DOC_PIXELARRAY_CLOSE "close()\n\nCloses the PixelArray, and releases Surface lock.\n\nclose() -> PixelArray\n\nThis method is for explicitly closing the PixelArray, and releasing\na lock on the Surface.\n\nNew in pygame 1.9.4."
