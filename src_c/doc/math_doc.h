/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_MATH "pygame.math\n\n\n\npygame module for vector classes\n\nThe pygame math module currently provides Vector classes in two and three\ndimensions, Vector2 and Vector3 respectively.\n\nThey support the following numerical operations: vec + vec, vec - vec,\nvec * number, number * vec, vec / number, vec // number, vec += vec,\nvec -= vec, vec *= number, vec /= number, vec //= number, round(vec, ndigits=0).\n\nAll these operations will be performed elementwise.\nIn addition vec * vec will perform a scalar-product (a.k.a. dot-product).\nIf you want to multiply every element from vector v with every element from\nvector w you can use the elementwise method: v.elementwise() * w\n\nThe coordinates of a vector can be retrieved or set using attributes or\nsubscripts\n\nv = pygame.Vector3()\n\nv.x = 5\nv[1] = 2 * v.x\nprint(v[1]) # 10\n\nv.x == v[0]\nv.y == v[1]\nv.z == v[2]\n\nMultiple coordinates can be set using slices or swizzling\n\nv = pygame.Vector2()\nv.xy = 1, 2\nv[:] = 1, 2\n\nNew in pygame 1.9.2pre.\n\nChanged in pygame 1.9.4: Removed experimental notice.\n\nChanged in pygame 1.9.4: Allow scalar construction like GLSL Vector2(2) == Vector2(2.0, 2.0)\n\nChanged in pygame 1.9.4: pygame.math import not required. More convenient pygame.Vector2 and pygame.Vector3.\n\nChanged in pygame-ce 2.1.4: round returns a new vector with components rounded to the specified digits."
#define DOC_MATH_CLAMP "pygame.math.clamp()\n\nreturns value clamped to min and max.\n\nclamp(value, min, max, /) -> float\n\nClamps a numeric value so that it's no lower than min, and no higher\nthan max.\n\nNew in pygame-ce 2.1.3."
#define DOC_MATH_LERP "pygame.math.lerp()\n\nreturns value linearly interpolated between a and b\n\nlerp(a, b, value, do_clamp=True, /) -> float\n\nReturns a number which is a linear interpolation between a\nand b. The third parameter determines how far between a and\nb the result is going to be.\nIf do_clamp is false, the result can exceed the range 0.0 to 1.0.\n\nThe formula is:\n\na * value + (1 - value) * b.\n\nNew in pygame-ce 2.4.0."
#define DOC_MATH_INVLERP "pygame.math.invlerp()\n\nreturns value inverse interpolated between a and b\n\ninvlerp(a, b, value, /) -> float\n\nReturns a number which is an inverse interpolation between a\nand b. The third parameter value is the result of the linear interpolation\nbetween a and b with a certain coefficient. In other words, this coefficient\nwill be the result of this function.\nIf b and a are equal, it raises a ValueError.\n\nThe formula is:\n\n(v - a)/(b - a).\n\nThis is an example explaining what is above :\n\n> a = 10\n> b = 20\n> pygame.math.invlerp(10, 20, 11.5)\n> 0.15\n> pygame.math.lerp(10, 20, 0.15)\n> 11.5\n\nNew in pygame-ce 2.5.0."
#define DOC_MATH_SMOOTHSTEP "pygame.math.smoothstep()\n\nreturns value smoothly interpolated between a and b.\n\nsmoothstep(a, b, value, /) -> float\n\nReturns a number which is a \"smooth\" interpolation between a\nand b. This means that the interpolation follows an s-shaped curve, with\nchange happening more slowly near the limits (0.0 and 1.0) and faster in the middle.\nThe third parameter determines how far between a and\nb the result is going to be.\n\nThe formula is:\n\na * interp + (1 - interp) * b\n\nwhere:\n\ninterp = value * value * (3 - 2 * value)\n\nNew in pygame-ce 2.4.0."
#define DOC_MATH_REMAP "pygame.math.remap()\n\nremaps value from given input range to given output range\n\nremap(i_min, i_max, o_min, o_max, value, /) -> float\n\nReturns a number which is the value remapped from [i_min, i_max] range to\n[o_min, o_max] range.\nIf i_min and i_max are equal, it raises a ValueError.\n\nExample:\n\n> value = 50\n> pygame.math.remap(0, 100, 0, 200, value)\n> 100.0\n\nNew in pygame-ce 2.5.0."
#define DOC_MATH_VECTOR2 "pygame.math.Vector2\n\na 2-Dimensional Vector\n\nVector2() -> Vector2(0, 0)\n\nVector2(int) -> Vector2\n\nVector2(float) -> Vector2\n\nVector2(Vector2) -> Vector2\n\nVector2(x, y) -> Vector2\n\nVector2((x, y)) -> Vector2\n\nSome general information about the Vector2 class.\n\nChanged in pygame-ce 2.1.3: Inherited methods of vector subclasses now correctly return an instance of the\nsubclass instead of the superclass\n\n"
#define DOC_MATH_VECTOR2_DOT "dot()\n\ncalculates the dot- or scalar-product with the other vector\n\ndot(Vector2, /) -> float"
#define DOC_MATH_VECTOR2_CROSS "cross()\n\ncalculates the cross- or vector-product\n\ncross(Vector2, /) -> float\n\ncalculates the third component of the cross-product."
#define DOC_MATH_VECTOR2_MAGNITUDE "magnitude()\n\nreturns the Euclidean magnitude of the vector.\n\nmagnitude() -> float\n\ncalculates the magnitude of the vector which follows from the\ntheorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2)"
#define DOC_MATH_VECTOR2_MAGNITUDESQUARED "magnitude_squared()\n\nreturns the squared magnitude of the vector.\n\nmagnitude_squared() -> float\n\ncalculates the magnitude of the vector which follows from the\ntheorem: vec.magnitude_squared() == vec.x**2 + vec.y**2. This\nis faster than vec.magnitude() because it avoids the square root."
#define DOC_MATH_VECTOR2_LENGTH "length()\n\nreturns the Euclidean length of the vector.\n\nlength() -> float\n\ncalculates the Euclidean length of the vector which follows from the\nPythagorean theorem: vec.length() == math.sqrt(vec.x**2 + vec.y**2)"
#define DOC_MATH_VECTOR2_LENGTHSQUARED "length_squared()\n\nreturns the squared Euclidean length of the vector.\n\nlength_squared() -> float\n\ncalculates the Euclidean length of the vector which follows from the\nPythagorean theorem: vec.length_squared() == vec.x**2 + vec.y**2.\nThis is faster than vec.length() because it avoids the square root."
#define DOC_MATH_VECTOR2_NORMALIZE "normalize()\n\nreturns a vector with the same direction but length 1.\n\nnormalize() -> Vector2\n\nReturns a new vector that has length equal to 1 and the same\ndirection as self."
#define DOC_MATH_VECTOR2_NORMALIZEIP "normalize_ip()\n\nnormalizes the vector in place so that its length is 1.\n\nnormalize_ip() -> None\n\nNormalizes the vector so that it has length equal to 1.\nThe direction of the vector is not changed."
#define DOC_MATH_VECTOR2_ISNORMALIZED "is_normalized()\n\ntests if the vector is normalized i.e. has length == 1.\n\nis_normalized() -> Bool\n\nReturns True if the vector has length equal to 1. Otherwise\nit returns False."
#define DOC_MATH_VECTOR2_SCALETOLENGTH "scale_to_length()\n\nscales the vector to a given length.\n\nscale_to_length(float, /) -> None\n\nScales the vector so that it has the given length. The direction of the\nvector is not changed. You can also scale to length 0. If the vector\nis the zero vector (i.e. has length 0 thus no direction) a\nValueError is raised."
#define DOC_MATH_VECTOR2_REFLECT "reflect()\n\nreturns a vector reflected of a given normal.\n\nreflect(Vector2, /) -> Vector2\n\nReturns a new vector that points in the direction as if self would bounce\nof a surface characterized by the given surface normal. The length of the\nnew vector is the same as self's."
#define DOC_MATH_VECTOR2_REFLECTIP "reflect_ip()\n\nreflect the vector of a given normal in place.\n\nreflect_ip(Vector2, /) -> None\n\nChanges the direction of self as if it would have been reflected of a\nsurface with the given surface normal."
#define DOC_MATH_VECTOR2_DISTANCETO "distance_to()\n\ncalculates the Euclidean distance to a given vector.\n\ndistance_to(Vector2, /) -> float"
#define DOC_MATH_VECTOR2_DISTANCESQUAREDTO "distance_squared_to()\n\ncalculates the squared Euclidean distance to a given vector.\n\ndistance_squared_to(Vector2, /) -> float"
#define DOC_MATH_VECTOR2_MOVETOWARDS "move_towards()\n\nreturns a vector moved toward the target by a given distance.\n\nmove_towards(Vector2, float, /) -> Vector2\n\nReturns a Vector which is moved towards the given Vector by a given\ndistance and does not overshoot past its target Vector.\nThe first parameter determines the target Vector, while the second\nparameter determines the delta distance. If the distance is in the\nnegatives, then it will move away from the target Vector.\n\nNew in pygame-ce 2.1.3."
#define DOC_MATH_VECTOR2_MOVETOWARDSIP "move_towards_ip()\n\nmoves the vector toward its target at a given distance.\n\nmove_towards_ip(Vector2, float, /) -> None\n\nMoves itself toward the given Vector at a given distance and does not\novershoot past its target Vector.\nThe first parameter determines the target Vector, while the second\nparameter determines the delta distance. If the distance is in the\nnegatives, then it will move away from the target Vector.\n\nNew in pygame-ce 2.1.3."
#define DOC_MATH_VECTOR2_LERP "lerp()\n\nreturns a linear interpolation to the given vector.\n\nlerp(Vector2, float, /) -> Vector2\n\nReturns a Vector which is a linear interpolation between self and the\ngiven Vector. The second parameter determines how far between self and\nother the result is going to be. It must be a value between 0 and 1\nwhere 0 means self and 1 means other will be returned."
#define DOC_MATH_VECTOR2_SLERP "slerp()\n\nreturns a spherical interpolation to the given vector.\n\nslerp(Vector2, float, /) -> Vector2\n\nCalculates the spherical interpolation from self to the given Vector. The\nsecond argument - often called t - must be in the range [-1, 1]. It\nparametrizes where - in between the two vectors - the result should be.\nIf a negative value is given the interpolation will not take the\ncomplement of the shortest path."
#define DOC_MATH_VECTOR2_SMOOTHSTEP "smoothstep()\n\nreturns a smooth interpolation to the given vector.\n\nsmoothstep(Vector2, float, /) -> Vector2\n\nReturns a Vector which is a smooth interpolation between self and the\ngiven Vector. This means that the interpolation follows an s-shaped curve, with\nchange happening more slowly near the limits (0.0 and 1.0) and faster in the middle.\nThe third parameter determines how far between the two vectors the result is going to be.\n\nThe formula is:\n\na * interp + (1 - interp) * b\n\nwhere:\n\ninterp = value * value * (3 - 2 * value)\n\nNew in pygame-ce 2.4.0."
#define DOC_MATH_VECTOR2_ELEMENTWISE "elementwise()\n\nThe next operation will be performed elementwise.\n\nelementwise() -> VectorElementwiseProxy\n\nApplies the following operation to each element of the vector."
#define DOC_MATH_VECTOR2_ROTATE "rotate()\n\nrotates a vector by a given angle in degrees.\n\nrotate(angle, /) -> Vector2\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise by the given angle in degrees.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR2_ROTATERAD "rotate_rad()\n\nrotates a vector by a given angle in radians.\n\nrotate_rad(angle, /) -> Vector2\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise by the given angle in radians.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.0.0."
#define DOC_MATH_VECTOR2_ROTATEIP "rotate_ip()\n\nrotates the vector by a given angle in degrees in place.\n\nrotate_ip(angle, /) -> None\n\nRotates the vector counterclockwise by the given angle in degrees. The\nlength of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR2_ROTATEIPRAD "rotate_ip_rad()\n\nrotates the vector by a given angle in radians in place.\n\nrotate_ip_rad(angle, /) -> None\n\nDEPRECATED: Use rotate_rad_ip() instead.\n\nNew in pygame 2.0.0.\n\nDeprecated since pygame 2.1.1."
#define DOC_MATH_VECTOR2_ROTATERADIP "rotate_rad_ip()\n\nrotates the vector by a given angle in radians in place.\n\nrotate_rad_ip(angle, /) -> None\n\nRotates the vector counterclockwise by the given angle in radians. The\nlength of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR2_ANGLETO "angle_to()\n\ncalculates the angle to a given vector in degrees.\n\nangle_to(Vector2, /) -> float\n\nReturns the angle from self to the passed Vector2 that would rotate self\nto be aligned with the passed Vector2 without crossing over the negative\nx-axis.\n\nangle_to image\n\nExample demonstrating the angle returned"
#define DOC_MATH_VECTOR2_ASPOLAR "as_polar()\n\nreturns a tuple with radial distance and azimuthal angle.\n\nas_polar() -> (r, phi)\n\nReturns a tuple (r, phi) where r is the radial distance, and phi\nis the azimuthal angle."
#define DOC_MATH_VECTOR2_FROMPOLAR "from_polar()\n\nSets x and y from a polar coordinates tuple.\n\nfrom_polar((r, phi), /) -> None\n\nSets x and y from a tuple (r, phi) where r is the radial distance, and\nphi is the azimuthal angle."
#define DOC_MATH_VECTOR2_PROJECT "project()\n\nprojects a vector onto another.\n\nproject(Vector2, /) -> Vector2\n\nReturns the projected vector. This is useful for collision detection in finding the components in a certain direction (e.g. in direction of the wall).\nFor a more detailed explanation see Wikipedia.\n\nNew in pygame 2.0.2."
#define DOC_MATH_VECTOR2_COPY "copy()\n\nReturns a copy of itself.\n\ncopy() -> Vector2\n\nReturns a new Vector2 having the same dimensions.\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR2_CLAMPMAGNITUDE "clamp_magnitude()\n\nReturns a copy of a vector with the magnitude clamped between max_length and min_length.\n\nclamp_magnitude(max_length, /) -> Vector2\n\nclamp_magnitude(min_length, max_length, /) -> Vector2\n\nExperimental: feature still in development available for testing and feedback. It may change.\nPlease leave clamp_magnitude feedback with authors\n\nReturns a new copy of a vector with the magnitude clamped between\nmax_length and min_length. If only one argument is passed, it is\ntaken to be the max_length\n\nThis function raises ValueError if min_length is greater than\nmax_length, or if either of these values are negative.\n\nNew in pygame-ce 2.1.3.\n\nChanged in pygame-ce 2.4.0: It is now possible to use clamp_magnitude on a zero-vector as long as min_length\nis unspecified or 0.\n\nBefore pygame-ce 2.4.0, attempting to clamp a zero vector would always raise a ValueError"
#define DOC_MATH_VECTOR2_CLAMPMAGNITUDEIP "clamp_magnitude_ip()\n\nClamps the vector's magnitude between max_length and min_length\n\nclamp_magnitude_ip(max_length, /) -> None\n\nclamp_magnitude_ip(min_length, max_length, /) -> None\n\nClamps the vector's magnitude between max_length and min_length.\nIf only one argument is passed, it is taken to be the max_length\n\nThis function raises ValueError if min_length is greater than\nmax_length, or if either of these values are negative.\n\nNew in pygame-ce 2.1.3.\n\nChanged in pygame-ce 2.4.0: It is now possible to use clamp_magnitude on a zero-vector as long as min_length\nis unspecified or 0.\n\nBefore pygame-ce 2.4.0, attempting to clamp a zero vector would always raise a ValueError"
#define DOC_MATH_VECTOR2_UPDATE "update()\n\nSets the coordinates of the vector.\n\nupdate() -> None\n\nupdate(int) -> None\n\nupdate(float) -> None\n\nupdate(Vector2) -> None\n\nupdate(x, y) -> None\n\nupdate((x, y)) -> None\n\nSets coordinates x and y in place.\n\nNew in pygame 1.9.5."
#define DOC_MATH_VECTOR2_EPSILON "epsilon\n\nDetermines the tolerance of vector calculations.\n\nBoth Vector classes have a value named epsilon that defaults to 1e-6.\nThis value acts as a numerical margin in various methods to account for floating point\narithmetic errors. Specifically, epsilon is used in the following places:\n\ncomparing Vectors (== and !=)\n\nthe is_normalized method (if the square of the length is within epsilon of 1, it's normalized)\n\nslerping (a Vector with a length of <epsilon is considered a zero vector, and can't slerp with that)\n\nreflection (can't reflect over the zero vector)\n\nprojection (can't project onto the zero vector)\n\nrotation (only used when rotating by a multiple of 90 degrees)\n\nWhile it's possible to change epsilon for a specific instance of a Vector, all the other Vectors\nwill retain the default value. Changing epsilon on a specific instance however could lead to some\nasymmetric behavior where symmetry would be expected, such as\n\nu = pygame.Vector2(0, 1)\nv = pygame.Vector2(0, 1.2)\nu.epsilon = 0.5 # don't set it nearly this large\n\nprint(u == v) # >> True\nprint(v == u) # >> False\n\nYou'll probably never have to change epsilon from the default value, but in rare situations you might\nfind that either the margin is too large or too small, in which case changing epsilon slightly\nmight help you out."
#define DOC_MATH_VECTOR3 "pygame.math.Vector3\n\na 3-Dimensional Vector\n\nVector3() -> Vector3(0, 0, 0)\n\nVector3(int) -> Vector3\n\nVector3(float) -> Vector3\n\nVector3(Vector3) -> Vector3\n\nVector3(x, y, z) -> Vector3\n\nVector3((x, y, z)) -> Vector3\n\nSome general information about the Vector3 class.\n\nChanged in pygame-ce 2.1.3: Inherited methods of vector subclasses now correctly return an instance of the\nsubclass instead of the superclass\n\n"
#define DOC_MATH_VECTOR3_DOT "dot()\n\ncalculates the dot- or scalar-product with the other vector\n\ndot(Vector3, /) -> float"
#define DOC_MATH_VECTOR3_CROSS "cross()\n\ncalculates the cross- or vector-product\n\ncross(Vector3, /) -> Vector3\n\ncalculates the cross-product."
#define DOC_MATH_VECTOR3_MAGNITUDE "magnitude()\n\nreturns the Euclidean magnitude of the vector.\n\nmagnitude() -> float\n\ncalculates the magnitude of the vector which follows from the\ntheorem: vec.magnitude() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)"
#define DOC_MATH_VECTOR3_MAGNITUDESQUARED "magnitude_squared()\n\nreturns the squared Euclidean magnitude of the vector.\n\nmagnitude_squared() -> float\n\ncalculates the magnitude of the vector which follows from the\ntheorem:\nvec.magnitude_squared() == vec.x**2 + vec.y**2 + vec.z**2.\nThis is faster than vec.magnitude() because it avoids the\nsquare root."
#define DOC_MATH_VECTOR3_LENGTH "length()\n\nreturns the Euclidean length of the vector.\n\nlength() -> float\n\ncalculates the Euclidean length of the vector which follows from the\nPythagorean theorem:\nvec.length() == math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)"
#define DOC_MATH_VECTOR3_LENGTHSQUARED "length_squared()\n\nreturns the squared Euclidean length of the vector.\n\nlength_squared() -> float\n\ncalculates the Euclidean length of the vector which follows from the\nPythagorean theorem:\nvec.length_squared() == vec.x**2 + vec.y**2 + vec.z**2.\nThis is faster than vec.length() because it avoids the square root."
#define DOC_MATH_VECTOR3_NORMALIZE "normalize()\n\nreturns a vector with the same direction but length 1.\n\nnormalize() -> Vector3\n\nReturns a new vector that has length equal to 1 and the same\ndirection as self."
#define DOC_MATH_VECTOR3_NORMALIZEIP "normalize_ip()\n\nnormalizes the vector in place so that its length is 1.\n\nnormalize_ip() -> None\n\nNormalizes the vector so that it has length equal to 1. The\ndirection of the vector is not changed."
#define DOC_MATH_VECTOR3_ISNORMALIZED "is_normalized()\n\ntests if the vector is normalized i.e. has length == 1.\n\nis_normalized() -> Bool\n\nReturns True if the vector has length equal to 1. Otherwise it\nreturns False."
#define DOC_MATH_VECTOR3_SCALETOLENGTH "scale_to_length()\n\nscales the vector to a given length.\n\nscale_to_length(float, /) -> None\n\nScales the vector so that it has the given length. The direction of the\nvector is not changed. You can also scale to length 0. If the vector\nis the zero vector (i.e. has length 0 thus no direction) a\nValueError is raised."
#define DOC_MATH_VECTOR3_REFLECT "reflect()\n\nreturns a vector reflected of a given normal.\n\nreflect(Vector3, /) -> Vector3\n\nReturns a new vector that points in the direction as if self would bounce\nof a surface characterized by the given surface normal. The length of the\nnew vector is the same as self's."
#define DOC_MATH_VECTOR3_REFLECTIP "reflect_ip()\n\nreflect the vector of a given normal in place.\n\nreflect_ip(Vector3, /) -> None\n\nChanges the direction of self as if it would have been reflected of a\nsurface with the given surface normal."
#define DOC_MATH_VECTOR3_DISTANCETO "distance_to()\n\ncalculates the Euclidean distance to a given vector.\n\ndistance_to(Vector3, /) -> float"
#define DOC_MATH_VECTOR3_DISTANCESQUAREDTO "distance_squared_to()\n\ncalculates the squared Euclidean distance to a given vector.\n\ndistance_squared_to(Vector3, /) -> float"
#define DOC_MATH_VECTOR3_MOVETOWARDS "move_towards()\n\nreturns a vector moved toward the target by a given distance.\n\nmove_towards(Vector3, float, /) -> Vector3\n\nReturns a Vector which is moved towards the given Vector by a given\ndistance and does not overshoot past its target Vector.\nThe first parameter determines the target Vector, while the second\nparameter determines the delta distance. If the distance is in the\nnegatives, then it will move away from the target Vector.\n\nNew in pygame-ce 2.1.3."
#define DOC_MATH_VECTOR3_MOVETOWARDSIP "move_towards_ip()\n\nmoves the vector toward its target at a given distance.\n\nmove_towards_ip(Vector3, float, /) -> None\n\nMoves itself toward the given Vector at a given distance and does not\novershoot past its target Vector.\nThe first parameter determines the target Vector, while the second\nparameter determines the delta distance. If the distance is in the\nnegatives, then it will move away from the target Vector.\n\nNew in pygame-ce 2.1.3."
#define DOC_MATH_VECTOR3_LERP "lerp()\n\nreturns a linear interpolation to the given vector.\n\nlerp(Vector3, float, /) -> Vector3\n\nReturns a Vector which is a linear interpolation between self and the\ngiven Vector. The second parameter determines how far between self an\nother the result is going to be. It must be a value between 0 and\n1, where 0 means self and 1 means other will be returned."
#define DOC_MATH_VECTOR3_SLERP "slerp()\n\nreturns a spherical interpolation to the given vector.\n\nslerp(Vector3, float, /) -> Vector3\n\nCalculates the spherical interpolation from self to the given Vector. The\nsecond argument - often called t - must be in the range [-1, 1]. It\nparametrizes where - in between the two vectors - the result should be.\nIf a negative value is given the interpolation will not take the\ncomplement of the shortest path."
#define DOC_MATH_VECTOR3_SMOOTHSTEP "smoothstep()\n\nreturns a smooth interpolation to the given vector.\n\nsmoothstep(Vector3, float, /) -> Vector3\n\nReturns a Vector which is a smooth interpolation between self and the\ngiven Vector. This means that the interpolation follows an s-shaped curve, with\nchange happening more slowly near the limits (0.0 and 1.0) and faster in the middle.\nThe third parameter determines how far between the two vectors the result is going to be.\n\nThe formula is:\n\na * interp + (1 - interp) * b\n\nwhere:\n\ninterp = value * value * (3 - 2 * value)\n\nNew in pygame-ce 2.4.0."
#define DOC_MATH_VECTOR3_ELEMENTWISE "elementwise()\n\nThe next operation will be performed elementwise.\n\nelementwise() -> VectorElementwiseProxy\n\nApplies the following operation to each element of the vector."
#define DOC_MATH_VECTOR3_ROTATE "rotate()\n\nrotates a vector by a given angle in degrees.\n\nrotate(angle, Vector3, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise by the given angle in degrees around the given axis.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATERAD "rotate_rad()\n\nrotates a vector by a given angle in radians.\n\nrotate_rad(angle, Vector3, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise by the given angle in radians around the given axis.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.0.0."
#define DOC_MATH_VECTOR3_ROTATEIP "rotate_ip()\n\nrotates the vector by a given angle in degrees in place.\n\nrotate_ip(angle, Vector3, /) -> None\n\nRotates the vector counterclockwise around the given axis by the given\nangle in degrees. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEIPRAD "rotate_ip_rad()\n\nrotates the vector by a given angle in radians in place.\n\nrotate_ip_rad(angle, Vector3, /) -> None\n\nDEPRECATED: Use rotate_rad_ip() instead.\n\nNew in pygame 2.0.0.\n\nDeprecated since pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATERADIP "rotate_rad_ip()\n\nrotates the vector by a given angle in radians in place.\n\nrotate_rad_ip(angle, Vector3, /) -> None\n\nRotates the vector counterclockwise around the given axis by the given\nangle in radians. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEX "rotate_x()\n\nrotates a vector around the x-axis by the angle in degrees.\n\nrotate_x(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the x-axis by the given angle in degrees.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEXRAD "rotate_x_rad()\n\nrotates a vector around the x-axis by the angle in radians.\n\nrotate_x_rad(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the x-axis by the given angle in radians.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.0.0."
#define DOC_MATH_VECTOR3_ROTATEXIP "rotate_x_ip()\n\nrotates the vector around the x-axis by the angle in degrees in place.\n\nrotate_x_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the x-axis by the given angle\nin degrees. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEXIPRAD "rotate_x_ip_rad()\n\nrotates the vector around the x-axis by the angle in radians in place.\n\nrotate_x_ip_rad(angle, /) -> None\n\nDEPRECATED: Use rotate_x_rad_ip() instead.\n\nNew in pygame 2.0.0.\n\nDeprecated since pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEXRADIP "rotate_x_rad_ip()\n\nrotates the vector around the x-axis by the angle in radians in place.\n\nrotate_x_rad_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the x-axis by the given angle\nin radians. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEY "rotate_y()\n\nrotates a vector around the y-axis by the angle in degrees.\n\nrotate_y(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the y-axis by the given angle in degrees.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEYRAD "rotate_y_rad()\n\nrotates a vector around the y-axis by the angle in radians.\n\nrotate_y_rad(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the y-axis by the given angle in radians.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.0.0."
#define DOC_MATH_VECTOR3_ROTATEYIP "rotate_y_ip()\n\nrotates the vector around the y-axis by the angle in degrees in place.\n\nrotate_y_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the y-axis by the given angle\nin degrees. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEYIPRAD "rotate_y_ip_rad()\n\nrotates the vector around the y-axis by the angle in radians in place.\n\nrotate_y_ip_rad(angle, /) -> None\n\nDEPRECATED: Use rotate_y_rad_ip() instead.\n\nNew in pygame 2.0.0.\n\nDeprecated since pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEYRADIP "rotate_y_rad_ip()\n\nrotates the vector around the y-axis by the angle in radians in place.\n\nrotate_y_rad_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the y-axis by the given angle\nin radians. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEZ "rotate_z()\n\nrotates a vector around the z-axis by the angle in degrees.\n\nrotate_z(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the z-axis by the given angle in degrees.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEZRAD "rotate_z_rad()\n\nrotates a vector around the z-axis by the angle in radians.\n\nrotate_z_rad(angle, /) -> Vector3\n\nReturns a vector which has the same length as self but is rotated\ncounterclockwise around the z-axis by the given angle in radians.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.0.0."
#define DOC_MATH_VECTOR3_ROTATEZIP "rotate_z_ip()\n\nrotates the vector around the z-axis by the angle in degrees in place.\n\nrotate_z_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the z-axis by the given angle\nin degrees. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed)."
#define DOC_MATH_VECTOR3_ROTATEZIPRAD "rotate_z_ip_rad()\n\nrotates the vector around the z-axis by the angle in radians in place.\n\nrotate_z_ip_rad(angle, /) -> None\n\nDEPRECATED: Use rotate_z_rad_ip() instead.\n\nDeprecated since pygame 2.1.1."
#define DOC_MATH_VECTOR3_ROTATEZRADIP "rotate_z_rad_ip()\n\nrotates the vector around the z-axis by the angle in radians in place.\n\nrotate_z_rad_ip(angle, /) -> None\n\nRotates the vector counterclockwise around the z-axis by the given angle\nin radians. The length of the vector is not changed.\n(Note that due to pygame's inverted y coordinate system, the rotation\nwill look clockwise if displayed).\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR3_ANGLETO "angle_to()\n\ncalculates the angle to a given vector in degrees.\n\nangle_to(Vector3, /) -> float\n\nReturns the angle between self and the given vector."
#define DOC_MATH_VECTOR3_ASSPHERICAL "as_spherical()\n\nreturns a tuple with radial distance, inclination and azimuthal angle.\n\nas_spherical() -> (r, theta, phi)\n\nReturns a tuple (r, theta, phi) where r is the radial distance, theta is\nthe inclination angle and phi is the azimuthal angle."
#define DOC_MATH_VECTOR3_FROMSPHERICAL "from_spherical()\n\nSets x, y and z from a spherical coordinates 3-tuple.\n\nfrom_spherical((r, theta, phi), /) -> None\n\nSets x, y and z from a tuple (r, theta, phi) where r is the radial\ndistance, theta is the inclination angle and phi is the azimuthal angle."
#define DOC_MATH_VECTOR3_PROJECT "project()\n\nprojects a vector onto another.\n\nproject(Vector3, /) -> Vector3\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/math.rst:4: (INFO/1) Duplicate explicit target name: \"wikipedia\".\n\nReturns the projected vector. This is useful for collision detection in finding the components in a certain direction (e.g. in direction of the wall).\nFor a more detailed explanation see Wikipedia.\n\nNew in pygame 2.0.2."
#define DOC_MATH_VECTOR3_COPY "copy()\n\nReturns a copy of itself.\n\ncopy() -> Vector3\n\nReturns a new Vector3 having the same dimensions.\n\nNew in pygame 2.1.1."
#define DOC_MATH_VECTOR3_CLAMPMAGNITUDE "clamp_magnitude()\n\nReturns a copy of a vector with the magnitude clamped between max_length and min_length.\n\nclamp_magnitude(max_length, /) -> Vector3\n\nclamp_magnitude(min_length, max_length, /) -> Vector3\n\nReturns a new copy of a vector with the magnitude clamped between\nmax_length and min_length. If only one argument is passed, it is\ntaken to be the max_length\n\nThis function raises ValueError if min_length is greater than\nmax_length, or if either of these values are negative.\n\nNew in pygame-ce 2.1.3.\n\nChanged in pygame-ce 2.4.0: It is now possible to use clamp_magnitude on a zero-vector as long as min_length\nis unspecified or 0.\n\nBefore pygame-ce 2.4.0, attempting to clamp a zero vector would always raise a ValueError"
#define DOC_MATH_VECTOR3_CLAMPMAGNITUDEIP "clamp_magnitude_ip()\n\nClamps the vector's magnitude between max_length and min_length\n\nclamp_magnitude_ip(max_length, /) -> None\n\nclamp_magnitude_ip(min_length, max_length, /) -> None\n\nClamps the vector's magnitude between max_length and min_length.\nIf only one argument is passed, it is taken to be the max_length\n\nThis function raises ValueError if min_length is greater than\nmax_length, or if either of these values are negative.\n\nNew in pygame-ce 2.1.3.\n\nChanged in pygame-ce 2.4.0: It is now possible to use clamp_magnitude on a zero-vector as long as min_length\nis unspecified or 0.\n\nBefore pygame-ce 2.4.0, attempting to clamp a zero vector would always raise a ValueError"
#define DOC_MATH_VECTOR3_UPDATE "update()\n\nSets the coordinates of the vector.\n\nupdate() -> None\n\nupdate(int) -> None\n\nupdate(float) -> None\n\nupdate(Vector3) -> None\n\nupdate(x, y, z) -> None\n\nupdate((x, y, z)) -> None\n\nSets coordinates x, y, and z in place.\n\nNew in pygame 1.9.5."
#define DOC_MATH_VECTOR3_EPSILON "epsilon\n\nDetermines the tolerance of vector calculations.\n\nWith lengths within this number, vectors are considered equal. For more information see pygame.math.Vector2.epsilon"
