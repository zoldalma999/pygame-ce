/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_RECT "pygame.Rect\n\npygame object for storing rectangular coordinates\n\nRect(left, top, width, height) -> Rect\n\nRect((left, top), (width, height)) -> Rect\n\nRect(object) -> Rect\n\nRect() -> Rect\n\nFRect(left, top, width, height) -> FRect\n\nFRect((left, top), (width, height)) -> FRect\n\nFRect(object) -> FRect\n\nFRect() -> FRect\n\nChanged in pygame-ce 2.2: Since version 2.2 there is another class called FRect that serves the same purpose as as Rect but it can hold floats instead of integers.\n\nPygame uses Rect objects to store and manipulate rectangular areas. A Rect\ncan be created from a combination of left, top, width, and height values.\nRects can also be created from python objects that are already a Rect or\nhave an attribute named \"rect\".\n\nAny pygame function that requires a Rect argument also accepts any of these\nvalues to construct a Rect. This makes it easier to create Rects on the fly\nas arguments to functions.\n\nIf no arguments are given, a zero Rect will be created (x=0, y=0, w=0, h=0).\nThis will only work when using the Rect/FRect class and not with functions\nthat require a Rect argument.\n\nThe Rect functions that change the position or size of a Rect return a new\ncopy of the Rect with the affected changes. The original Rect is not\nmodified. Some methods have an alternate \"in-place\" version that returns\nNone but affects the original Rect. These \"in-place\" methods are denoted\nwith the \"ip\" suffix.\n\nThe Rect object has several virtual attributes which can be used to move and\nalign the Rect:\n\nx,y\ntop, left, bottom, right\ntopleft, bottomleft, topright, bottomright\nmidtop, midleft, midbottom, midright\ncenter, centerx, centery\nsize, width, height\nw,h\n\nAll of these attributes can be assigned to:\n\nrect1.right = 10\nrect2.center = (20,30)\n\nAssigning to size, width or height changes the dimensions of the rectangle;\nall other assignments move the rectangle without resizing it. Notice that\nsome attributes are integers and others are pairs of integers.\n\nIf a Rect has a nonzero width or height, it will return True for a\nnonzero test. Some methods return a Rect with 0 size to represent an invalid\nrectangle. A Rect with a 0 size will not collide when using collision\ndetection methods (e.g. collidepoint(), colliderect(), etc.).\n\nThe coordinates for Rect objects are all integers. The size values can be\nprogrammed to have negative values, but these are considered illegal Rects\nfor most operations.\n\nThere are several collision tests between other rectangles. Most python\ncontainers can be searched for collisions against a single Rect.\n\nThe area covered by a Rect does not include the right- and bottom-most edge\nof pixels. If one Rect's bottom border is another Rect's top border (i.e.,\nrect1.bottom=rect2.top), the two meet exactly on the screen but do not\noverlap, and rect1.colliderect(rect2) returns false.\n\nThe Rect object is also iterable:\n\nr = Rect(0, 1, 2, 3)\nx, y, w, h = r\n\nNew in pygame 1.9.2: The Rect class can be subclassed. Methods such as copy() and move()\nwill recognize this and return instances of the subclass.\nHowever, the subclass's __init__() method is not called,\nand __new__() is assumed to take no arguments. So these methods should be\noverridden if any extra attributes need to be copied.\n\n"
#define DOC_RECT_COPY "copy()\n\ncopy the rectangle\n\ncopy() -> Rect\n\nReturns a new rectangle having the same position and size as the original.\n\nNew in pygame 1.9"
#define DOC_RECT_MOVE "move()\n\nmoves the rectangle\n\nmove(x, y, /) -> Rect\n\nReturns a new rectangle that is moved by the given offset. The x and y\narguments can be any integer value, positive or negative."
#define DOC_RECT_MOVEIP "move_ip()\n\nmoves the rectangle, in place\n\nmove_ip(x, y, /) -> None\n\nSame as the Rect.move() method, but operates in place."
#define DOC_RECT_MOVETO "move_to()\n\nmoves the rectangle to the specified position\n\nmove_to(**kwargs) -> Rect\n\nReturns a new rectangle that is moved to the given position and optionally resized.\nYou must provide keyword arguments to the method such as center, left,\nmidbottom, size that correspond to the rectangle's attributes and the\nmethod will return a new rectangle whose specified attributes are set to the given value.\n\nIt is similar to Surface.get_rect() but instead of a calling it as a surface method\nyou call it as a rectangle method.\n\nNew in pygame-ce 2.4.0."
#define DOC_RECT_INFLATE "inflate()\n\ngrow or shrink the rectangle size\n\ninflate(x, y, /) -> Rect\n\nReturns a new rectangle with the size changed by the given offset. The\nrectangle remains centered around its current center. Negative values\nwill shrink the rectangle. Note, uses integers, if the offset given is\ntoo small(< 2 > -2), center will be off."
#define DOC_RECT_INFLATEIP "inflate_ip()\n\ngrow or shrink the rectangle size, in place\n\ninflate_ip(x, y, /) -> None\n\nSame as the Rect.inflate() method, but operates in place."
#define DOC_RECT_SCALEBY "scale_by()\n\nscale the rectangle by given a multiplier\n\nscale_by(scale_by) -> Rect\n\nscale_by(x, y) -> Rect\n\nReturns a new rectangle with the size scaled by the given multipliers.\nThe rectangle remains centered around its current center. A single\nscalar or separate width and height scalars are allowed. Values above\none will increase the size of the rectangle, whereas values between\nzero and one will decrease the size of the rectangle.\n\nNew in pygame-ce 2.3.1.\n\nChanged in pygame-ce 2.5.2: the argument scale_by can now be passed as a positional argument"
#define DOC_RECT_SCALEBYIP "scale_by_ip()\n\ngrow or shrink the rectangle size, in place\n\nscale_by_ip(scale_by) -> None\n\nscale_by_ip(x, y) -> None\n\nSame as the Rect.scale_by() method, but operates in place.\n\nNew in pygame-ce 2.3.1.\n\nChanged in pygame-ce 2.5.2: the argument scale_by can now be passed as a positional argument"
#define DOC_RECT_UPDATE "update()\n\nsets the position and size of the rectangle\n\nupdate(left, top, width, height, /) -> None\n\nupdate((left, top), (width, height), /) -> None\n\nupdate(object, /) -> None\n\nSets the position and size of the rectangle, in place. See\nparameters for pygame.Rect() for the parameters of this function.\n\nNew in pygame 2.0.1."
#define DOC_RECT_CLAMP "clamp()\n\nmoves the rectangle inside another\n\nclamp(rect, /) -> Rect\n\nReturns a new rectangle that is moved to be completely inside the\nargument Rect. If the rectangle is too large to fit inside, it is\ncentered inside the argument Rect, but its size is not changed."
#define DOC_RECT_CLAMPIP "clamp_ip()\n\nmoves the rectangle inside another, in place\n\nclamp_ip(rect, /) -> None\n\nSame as the Rect.clamp() method, but operates in place."
#define DOC_RECT_CLIP "clip()\n\ncrops a rectangle inside another\n\nclip(rect, /) -> Rect\n\nReturns a new rectangle that is cropped to be completely inside the\nargument Rect. If the two rectangles do not overlap to begin with, a Rect\nwith 0 size is returned."
#define DOC_RECT_CLIPLINE "clipline()\n\ncrops a line inside a rectangle\n\nclipline(x1, y1, x2, y2, /) -> ((cx1, cy1), (cx2, cy2))\n\nclipline(x1, y1, x2, y2, /) -> ()\n\nclipline((x1, y1), (x2, y2), /) -> ((cx1, cy1), (cx2, cy2))\n\nclipline((x1, y1), (x2, y2), /) -> ()\n\nclipline((x1, y1, x2, y2), /) -> ((cx1, cy1), (cx2, cy2))\n\nclipline((x1, y1, x2, y2), /) -> ()\n\nclipline(((x1, y1), (x2, y2)), /) -> ((cx1, cy1), (cx2, cy2))\n\nclipline(((x1, y1), (x2, y2)), /) -> ()\n\nReturns the coordinates of a line that is cropped to be completely inside\nthe rectangle. If the line does not overlap the rectangle, then an empty\ntuple is returned.\n\nThe line to crop can be any of the following formats (floats can be used\nin place of ints, but they will be truncated):\n\nfour ints\n\n2 lists/tuples/Vector2s of 2 ints\n\na list/tuple of four ints\n\na list/tuple of 2 lists/tuples/Vector2s of 2 ints\n\nReturns\n\na tuple with the coordinates of the given line cropped to be\ncompletely inside the rectangle is returned, if the given line does\nnot overlap the rectangle, an empty tuple is returned\n\nReturn type\n\ntuple(tuple(int, int), tuple(int, int)) or ()\n\nRaises\n\nTypeError -- if the line coordinates are not given as one of the\nabove described line formats\n\nThis method can be used for collision detection between a rect and a\nline. See example code below.\n\nThe rect.bottom and rect.right attributes of a\npygame.Rect always lie one pixel outside of its actual border.\n\n# Example using clipline().\nclipped_line = rect.clipline(line)\n\nif clipped_line:\n    # If clipped_line is not an empty tuple then the line\n    # collides/overlaps with the rect. The returned value contains\n    # the endpoints of the clipped line.\n    start, end = clipped_line\n    x1, y1 = start\n    x2, y2 = end\nelse:\n    print(\"No clipping. The line is fully outside the rect.\")\n\nNew in pygame 2.0.0."
#define DOC_RECT_UNION "union()\n\njoins two rectangles into one\n\nunion(rect, /) -> Rect\n\nReturns a new rectangle that completely covers the area of the two\nprovided rectangles. There may be area inside the new Rect that is not\ncovered by the originals."
#define DOC_RECT_UNIONIP "union_ip()\n\njoins two rectangles into one, in place\n\nunion_ip(rect, /) -> None\n\nSame as the Rect.union() method, but operates in place."
#define DOC_RECT_UNIONALL "unionall()\n\nthe union of many rectangles\n\nunionall(rect_sequence, /) -> Rect\n\nReturns the union of one rectangle with a sequence of many rectangles."
#define DOC_RECT_UNIONALLIP "unionall_ip()\n\nthe union of many rectangles, in place\n\nunionall_ip(rect_sequence, /) -> None\n\nThe same as the Rect.unionall() method, but operates in place."
#define DOC_RECT_FIT "fit()\n\nresize and move a rectangle with aspect ratio\n\nfit(rect, /) -> Rect\n\nReturns a new rectangle that is moved and resized to fit another. The\naspect ratio of the original Rect is preserved, so the new rectangle may\nbe smaller than the target in either width or height."
#define DOC_RECT_NORMALIZE "normalize()\n\ncorrect negative sizes\n\nnormalize() -> None\n\nThis will flip the width or height of a rectangle if it has a negative\nsize. The rectangle will remain in the same place, with only the sides\nswapped."
#define DOC_RECT_CONTAINS "contains()\n\ntest if one rectangle is inside another\n\ncontains(rect, /) -> bool\n\nReturns true when the argument is completely inside the Rect."
#define DOC_RECT_COLLIDEPOINT "collidepoint()\n\ntest if a point is inside a rectangle\n\ncollidepoint(x, y, /) -> bool\n\ncollidepoint((x, y), /) -> bool\n\nReturns true if the given point is inside the rectangle. A point along\nthe right or bottom edge is not considered to be inside the rectangle.\n\nFor collision detection between a rect and a line the clipline()\nmethod can be used."
#define DOC_RECT_COLLIDERECT "colliderect()\n\ntest if two rectangles overlap\n\ncolliderect(rect, /) -> bool\n\nReturns true if any portion of either rectangle overlap (except the\ntop+bottom or left+right edges).\n\nFor collision detection between a rect and a line the clipline()\nmethod can be used."
#define DOC_RECT_COLLIDELIST "collidelist()\n\ntest if one rectangle in a list intersects\n\ncollidelist(list, /) -> index\n\nTest whether the rectangle collides with any in a sequence of rectangles.\nThe index of the first collision found is returned. If no collisions are\nfound an index of -1 is returned."
#define DOC_RECT_COLLIDELISTALL "collidelistall()\n\ntest if all rectangles in a list intersect\n\ncollidelistall(list, /) -> indices\n\nReturns a list of all the indices that contain rectangles that collide\nwith the Rect. If no intersecting rectangles are found, an empty list is\nreturned.\n\nNot only Rects are valid arguments, but these are all valid calls:\n\nRect = pygame.Rect\nr = Rect(0, 0, 10, 10)\n\nlist_of_rects = [Rect(1, 1, 1, 1), Rect(2, 2, 2, 2)]\nindices0 = r.collidelistall(list_of_rects)\n\nlist_of_lists = [[1, 1, 1, 1], [2, 2, 2, 2]]\nindices1 = r.collidelistall(list_of_lists)\n\nlist_of_tuples = [(1, 1, 1, 1), (2, 2, 2, 2)]\nindices2 = r.collidelistall(list_of_tuples)\n\nlist_of_double_tuples = [((1, 1), (1, 1)), ((2, 2), (2, 2))]\nindices3 = r.collidelistall(list_of_double_tuples)\n\nclass ObjectWithRectAttribute(object):\n    def __init__(self, r):\n        self.rect = r\n\nlist_of_object_with_rect_attribute = [\n    ObjectWithRectAttribute(Rect(1, 1, 1, 1)),\n    ObjectWithRectAttribute(Rect(2, 2, 2, 2)),\n]\nindices4 = r.collidelistall(list_of_object_with_rect_attribute)\n\nclass ObjectWithCallableRectAttribute(object):\n    def __init__(self, r):\n        self._rect = r\n\n    def rect(self):\n        return self._rect\n\nlist_of_object_with_callable_rect = [\n    ObjectWithCallableRectAttribute(Rect(1, 1, 1, 1)),\n    ObjectWithCallableRectAttribute(Rect(2, 2, 2, 2)),\n]\nindices5 = r.collidelistall(list_of_object_with_callable_rect)"
#define DOC_RECT_COLLIDEOBJECTS "collideobjects()\n\ntest if any object in a list intersects\n\ncollideobjects(rect_list) -> object\n\ncollideobjects(obj_list, key=func) -> object\n\nTest whether the rectangle collides with any object in the sequence.\nThe object of the first collision found is returned. If no collisions are\nfound then None is returned\n\nIf key is given, then it should be a method taking an object from the list\nas input and returning a rect like object e.g. lambda obj: obj.rectangle.\nIf an object has multiple attributes of type Rect then key could return one\nof them.\n\nr = Rect(1, 1, 10, 10)\n\nrects = [\n    Rect(1, 1, 10, 10),\n    Rect(5, 5, 10, 10),\n    Rect(15, 15, 1, 1),\n    Rect(2, 2, 1, 1),\n]\n\nresult = r.collideobjects(rects)  # -> <rect(1, 1, 10, 10)>\nprint(result)\n\nclass ObjectWithSomRectAttribute:\n    def __init__(self, name, collision_box, draw_rect):\n        self.name = name\n        self.draw_rect = draw_rect\n        self.collision_box = collision_box\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__}(\"{self.name}\", {list(self.collision_box)}, {list(self.draw_rect)})>'\n\nobjects = [\n    ObjectWithSomRectAttribute(\"A\", Rect(15, 15, 1, 1), Rect(150, 150, 50, 50)),\n    ObjectWithSomRectAttribute(\"B\", Rect(1, 1, 10, 10), Rect(300, 300, 50, 50)),\n    ObjectWithSomRectAttribute(\"C\", Rect(5, 5, 10, 10), Rect(200, 500, 50, 50)),\n]\n\n# collision = r.collideobjects(objects) # this does not work because the items in the list are no Rect like object\ncollision = r.collideobjects(\n    objects, key=lambda o: o.collision_box\n)  # -> <ObjectWithSomRectAttribute(\"B\", [1, 1, 10, 10], [300, 300, 50, 50])>\nprint(collision)\n\nscreen_rect = r.collideobjects(objects, key=lambda o: o.draw_rect)  # -> None\nprint(screen_rect)\n\nNew in pygame-ce 2.1.3."
#define DOC_RECT_COLLIDEOBJECTSALL "collideobjectsall()\n\ntest if all objects in a list intersect\n\ncollideobjectsall(rect_list) -> objects\n\ncollideobjectsall(obj_list, key=func) -> objects\n\nReturns a list of all the objects that contain rectangles that collide\nwith the Rect. If no intersecting objects are found, an empty list is\nreturned.\n\nIf key is given, then it should be a method taking an object from the list\nas input and returning a rect like object e.g. lambda obj: obj.rectangle.\nIf an object has multiple attributes of type Rect then key could return one\nof them.\n\nr = Rect(1, 1, 10, 10)\n\nrects = [\n    Rect(1, 1, 10, 10),\n    Rect(5, 5, 10, 10),\n    Rect(15, 15, 1, 1),\n    Rect(2, 2, 1, 1),\n]\n\nresult = r.collideobjectsall(\n    rects\n)  # -> [<rect(1, 1, 10, 10)>, <rect(5, 5, 10, 10)>, <rect(2, 2, 1, 1)>]\nprint(result)\n\nclass ObjectWithSomRectAttribute:\n    def __init__(self, name, collision_box, draw_rect):\n        self.name = name\n        self.draw_rect = draw_rect\n        self.collision_box = collision_box\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__}(\"{self.name}\", {list(self.collision_box)}, {list(self.draw_rect)})>'\n\nobjects = [\n    ObjectWithSomRectAttribute(\"A\", Rect(1, 1, 10, 10), Rect(300, 300, 50, 50)),\n    ObjectWithSomRectAttribute(\"B\", Rect(5, 5, 10, 10), Rect(200, 500, 50, 50)),\n    ObjectWithSomRectAttribute(\"C\", Rect(15, 15, 1, 1), Rect(150, 150, 50, 50)),\n]\n\n# collisions = r.collideobjectsall(objects) # this does not work because ObjectWithSomRectAttribute is not a Rect like object\ncollisions = r.collideobjectsall(\n    objects, key=lambda o: o.collision_box\n)  # -> [<ObjectWithSomRectAttribute(\"A\", [1, 1, 10, 10], [300, 300, 50, 50])>, <ObjectWithSomRectAttribute(\"B\", [5, 5, 10, 10], [200, 500, 50, 50])>]\nprint(collisions)\n\nscreen_rects = r.collideobjectsall(objects, key=lambda o: o.draw_rect)  # -> []\nprint(screen_rects)\n\nNew in pygame-ce 2.1.3."
#define DOC_RECT_COLLIDEDICT "collidedict()\n\ntest if one rectangle in a dictionary intersects\n\ncollidedict(rect_dict) -> (key, value)\n\ncollidedict(rect_dict) -> None\n\ncollidedict(rect_dict, values=False) -> (key, value)\n\ncollidedict(rect_dict, values=False) -> None\n\nReturns the first key and value pair that intersects with the calling\nRect object. If no collisions are found, None is returned. If\nvalues is False (default) then the dict's keys will be used in the\ncollision detection, otherwise the dict's values will be used.\n\nRect objects cannot be used as keys in a dictionary (they are not\nhashable), so they must be converted to a tuple.\ne.g. rect.collidedict({tuple(key_rect) : value})\n\nChanged in pygame-ce 2.4.0: values is now accepted as a keyword argument. Type Stub updated\nto use boolean True or False, but any truthy or falsy value\nwill be valid."
#define DOC_RECT_COLLIDEDICTALL "collidedictall()\n\ntest if all rectangles in a dictionary intersect\n\ncollidedictall(rect_dict) -> [(key, value), ...]\n\ncollidedictall(rect_dict, values=False) -> [(key, value), ...]\n\nReturns a list of all the key and value pairs that intersect with the\ncalling Rect object. If no collisions are found an empty list is returned.\nIf values is False (default) then the dict's keys will be used in the\ncollision detection, otherwise the dict's values will be used.\n\nRect objects cannot be used as keys in a dictionary (they are not\nhashable), so they must be converted to a tuple.\ne.g. rect.collidedictall({tuple(key_rect) : value})\n\nChanged in pygame-ce 2.4.0: values is now accepted as a keyword argument. Type Stub updated\nto use boolean True or False, but any truthy or falsy value\nwill be valid."
