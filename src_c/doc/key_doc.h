/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_KEY "pygame.key\n\n\n\npygame module to work with the keyboard\n\nThis module contains functions for dealing with the keyboard.\n\nThe pygame.event queue gets pygame.KEYDOWN and pygame.KEYUP\nevents when the keyboard buttons are pressed and released. Both events have\nkey and mod attributes.\n\nkey: an integer ID representing every key\non the keyboard\n\nmod: a bitmask of all the modifier keys\nthat were in a pressed state when the event occurred\n\nThe pygame.KEYDOWN event has the additional attributes unicode and\nscancode.\n\nunicode: a single character string that is the fully translated\ncharacter entered, this takes into account the shift and composition keys\n\nscancode: the platform-specific key code, which could be different from\nkeyboard to keyboard, but is useful for key selection of weird keys like\nthe multimedia keys\n\nNew in pygame 2.0.0: The pygame.TEXTINPUT event is preferred to the unicode attribute\nof pygame.KEYDOWN. The attribute text contains the input.\n\n\n\nThe following is a list of all the constants (from pygame.locals) used to\nrepresent keyboard keys.\n\nPortability note: The integers for key constants differ between pygame 1 and 2.\nAlways use key constants (K_a) rather than integers directly (97) so\nthat your key handling code works well on both pygame 1 and pygame 2.\n\npygame\nConstant      ASCII   Description\n---------------------------------\nK_BACKSPACE   \\b      backspace\nK_TAB         \\t      tab\nK_CLEAR               clear\nK_RETURN      \\r      return\nK_PAUSE               pause\nK_ESCAPE      ^[      escape\nK_SPACE               space\nK_EXCLAIM     !       exclaim\nK_QUOTEDBL    \"       quotedbl\nK_HASH        #       hash\nK_DOLLAR      $       dollar\nK_AMPERSAND   &       ampersand\nK_QUOTE               quote\nK_LEFTPAREN   (       left parenthesis\nK_RIGHTPAREN  )       right parenthesis\nK_ASTERISK    *       asterisk\nK_PLUS        +       plus sign\nK_COMMA       ,       comma\nK_MINUS       -       minus sign\nK_PERIOD      .       period\nK_SLASH       /       forward slash\nK_0           0       0\nK_1           1       1\nK_2           2       2\nK_3           3       3\nK_4           4       4\nK_5           5       5\nK_6           6       6\nK_7           7       7\nK_8           8       8\nK_9           9       9\nK_COLON       :       colon\nK_SEMICOLON   ;       semicolon\nK_LESS        <       less-than sign\nK_EQUALS      =       equals sign\nK_GREATER     >       greater-than sign\nK_QUESTION    ?       question mark\nK_AT          @       at\nK_LEFTBRACKET [       left bracket\nK_BACKSLASH   \\       backslash\nK_RIGHTBRACKET ]      right bracket\nK_CARET       ^       caret\nK_UNDERSCORE  _       underscore\nK_BACKQUOTE   `       grave\nK_a           a       a\nK_b           b       b\nK_c           c       c\nK_d           d       d\nK_e           e       e\nK_f           f       f\nK_g           g       g\nK_h           h       h\nK_i           i       i\nK_j           j       j\nK_k           k       k\nK_l           l       l\nK_m           m       m\nK_n           n       n\nK_o           o       o\nK_p           p       p\nK_q           q       q\nK_r           r       r\nK_s           s       s\nK_t           t       t\nK_u           u       u\nK_v           v       v\nK_w           w       w\nK_x           x       x\nK_y           y       y\nK_z           z       z\nK_DELETE              delete\nK_KP0                 keypad 0\nK_KP1                 keypad 1\nK_KP2                 keypad 2\nK_KP3                 keypad 3\nK_KP4                 keypad 4\nK_KP5                 keypad 5\nK_KP6                 keypad 6\nK_KP7                 keypad 7\nK_KP8                 keypad 8\nK_KP9                 keypad 9\nK_KP_PERIOD   .       keypad period\nK_KP_DIVIDE   /       keypad divide\nK_KP_MULTIPLY *       keypad multiply\nK_KP_MINUS    -       keypad minus\nK_KP_PLUS     +       keypad plus\nK_KP_ENTER    \\r      keypad enter\nK_KP_EQUALS   =       keypad equals\nK_UP                  up arrow\nK_DOWN                down arrow\nK_RIGHT               right arrow\nK_LEFT                left arrow\nK_INSERT              insert\nK_HOME                home\nK_END                 end\nK_PAGEUP              page up\nK_PAGEDOWN            page down\nK_F1                  F1\nK_F2                  F2\nK_F3                  F3\nK_F4                  F4\nK_F5                  F5\nK_F6                  F6\nK_F7                  F7\nK_F8                  F8\nK_F9                  F9\nK_F10                 F10\nK_F11                 F11\nK_F12                 F12\nK_F13                 F13\nK_F14                 F14\nK_F15                 F15\nK_NUMLOCK             numlock\nK_CAPSLOCK            capslock\nK_SCROLLOCK           scrollock\nK_RSHIFT              right shift\nK_LSHIFT              left shift\nK_RCTRL               right control\nK_LCTRL               left control\nK_RALT                right alt\nK_LALT                left alt\nK_RMETA               right meta\nK_LMETA               left meta\nK_LSUPER              left Windows key\nK_RSUPER              right Windows key\nK_MODE                mode shift\nK_HELP                help\nK_PRINT               print screen\nK_SYSREQ              sysrq\nK_BREAK               break\nK_MENU                menu\nK_POWER               power\nK_EURO                Euro\nK_AC_BACK             Android back button\n\n\n\nThe keyboard also has a list of modifier states (from pygame.locals) that\ncan be assembled by bitwise-ORing them together.\n\npygame\nConstant      Description\n-------------------------\nKMOD_NONE     no modifier keys pressed\nKMOD_LSHIFT   left shift\nKMOD_RSHIFT   right shift\nKMOD_SHIFT    left shift or right shift or both\nKMOD_LCTRL    left control\nKMOD_RCTRL    right control\nKMOD_CTRL     left control or right control or both\nKMOD_LALT     left alt\nKMOD_RALT     right alt\nKMOD_ALT      left alt or right alt or both\nKMOD_LMETA    left meta\nKMOD_RMETA    right meta\nKMOD_META     left meta or right meta or both\nKMOD_CAPS     caps lock\nKMOD_NUM      num lock\nKMOD_MODE     AltGr\n\nThe modifier information is contained in the mod attribute of the\npygame.KEYDOWN and pygame.KEYUP events. The mod attribute is a\nbitmask of all the modifier keys that were in a pressed state when the event\noccurred. The modifier information can be decoded using a bitwise AND (except\nfor KMOD_NONE, which should be compared using equals ==). For example:\n\nfor event in pygame.event.get():\n    if event.type == pygame.KEYDOWN or event.type == pygame.KEYUP:\n        if event.mod == pygame.KMOD_NONE:\n            print('No modifier keys were in a pressed state when this '\n                  'event occurred.')\n        else:\n            if event.mod & pygame.KMOD_LSHIFT:\n                print('Left shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_RSHIFT:\n                print('Right shift was in a pressed state when this event '\n                      'occurred.')\n            if event.mod & pygame.KMOD_SHIFT:\n                print('Left shift or right shift or both were in a '\n                      'pressed state when this event occurred.')"
#define DOC_KEY_GETFOCUSED "pygame.key.get_focused()\n\ntrue if the display is receiving keyboard input from the system\n\nget_focused() -> bool\n\nReturns True when the display window has keyboard focus from the\nsystem. If the display needs to ensure it does not lose keyboard focus, it\ncan use pygame.event.set_grab() to grab all input."
#define DOC_KEY_GETPRESSED "pygame.key.get_pressed()\n\nget the state of all keyboard buttons\n\nget_pressed() -> bools\n\nReturns a sequence of boolean values representing the state of every key on\nthe keyboard. Use the key constant values to index the array. A True\nvalue means that the button is pressed.\n\nGetting the list of pushed buttons with this function is not the proper\nway to handle text entry from the user. There is no way to know the order\nof keys pressed, and rapidly pushed keys can be completely unnoticed\nbetween two calls to pygame.key.get_pressed(). There is also no way to\ntranslate these pushed keys into a fully translated character value. See\nthe pygame.KEYDOWN events on the pygame.event queue for this\nfunctionality.\n\nChanged in pygame-ce 2.1.4: The collection of bools returned by get_pressed can not be iterated\nover because the indexes of the internal tuple does not correspond to the\nkeycodes."
#define DOC_KEY_GETJUSTPRESSED "pygame.key.get_just_pressed()\n\nreturns a pygame.key.ScancodeWrapper containing the most recent key presses\n\nget_just_pressed() -> bools\n\nReturns a mapping from key codes to booleans indicating which keys were\nnewly pressed as of the last time events were processed. This can be used\nas a convenience function to detect keys that were pressed \"this frame.\"\n\nThe result of this function is updated when new events are processed,\ne.g. in pygame.event.get() or pygame.event.pump().\n\nA key can be marked as \"just pressed\" even if it is not currently pressed\naccording to pygame.key.get_pressed(), if it was pressed and released\nagain during the same frame. Multiple presses and releases of the same key\nare not distinguished from a single press with this function.\n\npygame.key.get_just_released()\n\nIf you require getting the key presses in order, use the event queue\nKEYDOWN events\n\nif pygame.key.get_just_pressed()[pygame.K_b]:\n   print(\"B key just pressed\")\n\nNew in pygame-ce 2.4.0."
#define DOC_KEY_GETJUSTRELEASED "pygame.key.get_just_released()\n\nreturns a pygame.key.ScancodeWrapper containing the most recent key releases\n\nget_just_pressed() -> bools\n\nReturns a mapping from key codes to booleans indicating which keys were\nnewly released as of the last time events were processed. This can be used\nas a convenience function to detect keys that were released \"this frame.\"\n\nThe result of this function is updated when new events are processed,\ne.g. in pygame.event.get() or pygame.event.pump().\n\npygame.key.get_just_pressed()\n\nIf you require getting the key releases in order, use the event queue\nKEYUP events.\n\nif pygame.key.get_just_released()[pygame.K_b]:\n   print(\"B key just released\")\n\nNew in pygame-ce 2.4.0."
#define DOC_KEY_GETMODS "pygame.key.get_mods()\n\ndetermine which modifier keys are being held\n\nget_mods() -> int\n\nReturns a single integer representing a bitmask of all the modifier keys\nbeing held. Using bitwise operators you can test if specific\nmodifier keys are pressed."
#define DOC_KEY_SETMODS "pygame.key.set_mods()\n\ntemporarily set which modifier keys are pressed\n\nset_mods(int, /) -> None\n\nCreate a bitmask of the modifier key constants\nyou want to impose on your program."
#define DOC_KEY_SETREPEAT "pygame.key.set_repeat()\n\ncontrol how held keys are repeated\n\nset_repeat() -> None\n\nset_repeat(delay, /) -> None\n\nset_repeat(delay, interval, /) -> None\n\nWhen the keyboard repeat is enabled, keys that are held down will generate\nmultiple pygame.KEYDOWN events. The delay parameter is the number of\nmilliseconds before the first repeated pygame.KEYDOWN event will be sent.\nAfter that, another pygame.KEYDOWN event will be sent every interval\nmilliseconds. If a delay value is provided and an interval value is\nnot provided or is 0, then the interval will be set to the same value as\ndelay.\n\nTo disable key repeat call this function with no arguments or with delay\nset to 0.\n\nWhen pygame is initialized the key repeat is disabled.\n\nRaises\n\nValueError -- if delay or interval is < 0\n\nChanged in pygame 2.0.0: A ValueError is now raised (instead of a\npygame.error) if delay or interval is < 0."
#define DOC_KEY_GETREPEAT "pygame.key.get_repeat()\n\nsee how held keys are repeated\n\nget_repeat() -> (delay, interval)\n\nGet the delay and interval keyboard repeat values. Refer to\npygame.key.set_repeat() for a description of these values.\n\nNew in pygame 1.8."
#define DOC_KEY_NAME "pygame.key.name()\n\nget the name of a key identifier\n\nname(key, use_compat=True) -> str\n\nGet the descriptive name of the button from a keyboard button id constant.\nReturns an empty string (\"\") if the key is not found.\n\nIf use_compat argument is True (which is the default), this function\nreturns the legacy name of a key where applicable. The return value is\nexpected to be the same across different pygame versions (provided the\ncorresponding key constant exists and is unique). If the return value is\npassed to the key_code function, the original constant will be returned.\n\nIf this argument is False, the returned name may be prettier to display\nand may cover a wider range of keys than with use_compat, but there are\nno guarantees that this name will be the same across different pygame\nversions. If the name returned is passed to the key_code function, the\noriginal constant is returned back (this is an implementation detail which\nmay change later, do not rely on this)\n\nChanged in pygame-ce 2.1.3: Added use_compat argument and guaranteed API stability for it"
#define DOC_KEY_KEYCODE "pygame.key.key_code()\n\nget the key identifier from a key name\n\nkey_code(name=string) -> int\n\nGet the key identifier code from the descriptive name of the key. This\nreturns an integer matching one of the K_* keycodes. For example:\n\n>>> pygame.key.key_code(\"return\") == pygame.K_RETURN\nTrue\n>>> pygame.key.key_code(\"0\") == pygame.K_0\nTrue\n>>> pygame.key.key_code(\"space\") == pygame.K_SPACE\nTrue\n\nRaises\n\nValueError -- if the key name is not known.\n\nNew in pygame 2.0.0."
#define DOC_KEY_STARTTEXTINPUT "pygame.key.start_text_input()\n\nstart handling Unicode text input events\n\nstart_text_input() -> None\n\nStart receiving pygame.TEXTEDITING and pygame.TEXTINPUT\nevents. If applicable, show the on-screen keyboard or IME editor.\n\nFor many languages, key presses will automatically generate a\ncorresponding pygame.TEXTINPUT event. Special keys like\nescape or function keys, and certain key combinations will not\ngenerate pygame.TEXTINPUT events.\n\nIn other languages, entering a single symbol may require multiple\nkey presses, or a language-specific user interface. In this case,\npygame.TEXTINPUT events are preferable to pygame.KEYDOWN\nevents for text input.\n\nA pygame.TEXTEDITING event is received when an IME composition\nis started or changed. It contains the composition text, length,\nand editing start position within the composition (attributes\ntext, length, and start, respectively).\nWhen the composition is committed (or non-IME input is received),\na pygame.TEXTINPUT event is generated.\n\nText input events handling is on by default.\n\nNew in pygame 2.0.0."
#define DOC_KEY_STOPTEXTINPUT "pygame.key.stop_text_input()\n\nstop handling Unicode text input events\n\nstop_text_input() -> None\n\nStop receiving pygame.TEXTEDITING and pygame.TEXTINPUT\nevents. If an on-screen keyboard or IME editor was shown with\npygame.key.start_text_input(), hide it again.\n\nText input events handling is on by default.\n\nTo avoid triggering the IME editor or the on-screen keyboard\nwhen the user is holding down a key during gameplay, text input\nshould be disabled once text entry is finished, or when the user\nclicks outside of a text box.\n\nNew in pygame 2.0.0."
#define DOC_KEY_SETTEXTINPUTRECT "pygame.key.set_text_input_rect()\n\ncontrols the position of the candidate list\n\nset_text_input_rect(rect, /) -> None\n\nThis sets the rectangle used for typing with an IME.\nIt controls where the candidate list will open, if supported.\n\nNew in pygame 2.0.0."
