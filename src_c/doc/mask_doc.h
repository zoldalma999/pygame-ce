/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_MASK "pygame.mask\n\n\n\npygame module for image masks.\n\nUseful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel\nto store which parts collide.\n\nNew in pygame 1.8.\n\nChanged in pygame 2.0.2: Mask functions now support keyword arguments.\n\nChanged in pygame 2.0.2: Mask functions that take positions or offsets now\nsupport pygame.math.Vector2 arguments."
#define DOC_MASK_FROMSURFACE "pygame.mask.from_surface()\n\nCreates a Mask from the given surface\n\nfrom_surface(surface) -> Mask\n\nfrom_surface(surface, threshold=127) -> Mask\n\nCreates a Mask object from the given surface by setting all the\nopaque pixels and not setting the transparent pixels.\n\nIf the surface uses a color-key, then it is used to decide which bits in\nthe resulting mask are set. All the pixels that are not equal to the\ncolor-key are set and the pixels equal to the color-key are not set.\n\nIf a color-key is not used, then the alpha value of each pixel is used to\ndecide which bits in the resulting mask are set. All the pixels that have an\nalpha value greater than the threshold parameter are set and the\npixels with an alpha value less than or equal to the threshold are\nnot set.\n\nParameters\n\nsurface (Surface) -- the surface to create the mask from\n\nthreshold (int) -- (optional) the alpha threshold (default is 127) to\ncompare with each surface pixel's alpha value, if the surface is\ncolor-keyed this parameter is ignored\n\nReturns\n\na newly created Mask object from the given surface\n\nReturn type\n\nMask\n\nThis function is used to create the masks for\npygame.sprite.collide_mask()."
#define DOC_MASK_FROMTHRESHOLD "pygame.mask.from_threshold()\n\nCreates a mask by thresholding Surfaces\n\nfrom_threshold(surface, color) -> Mask\n\nfrom_threshold(surface, color, threshold=(0, 0, 0, 255), othersurface=None, palette_colors=1) -> Mask\n\nThis is a more featureful method of getting a Mask from a surface.\n\nIf the optional othersurface is not used, all the pixels within the\nthreshold of the color parameter are set in the resulting mask.\n\nIf the optional othersurface is used, every pixel in the first surface\nthat is within the threshold of the corresponding pixel in\nothersurface is set in the resulting mask.\n\nParameters\n\nsurface (Surface) -- the surface to create the mask from\n\ncolor (pygame.typing.ColorLike) -- color used to check if the surface's pixels are within the\ngiven threshold range, this parameter is ignored if the optional\nothersurface parameter is supplied\n\nthreshold (pygame.typing.ColorLike) -- (optional) the threshold range used to check the difference\nbetween two colors (default is (0, 0, 0, 255))\n\nothersurface (Surface) -- (optional) used to check whether the pixels of\nthe first surface are within the given threshold range of the pixels\nfrom this surface (default is None)\n\npalette_colors (int) -- (optional) indicates whether to use the palette\ncolors or not, a nonzero value causes the palette colors to be used and a\n0 causes them not to be used (default is 1)\n\nReturns\n\na newly created Mask object from the given surface\n\nReturn type\n\nMask"
#define DOC_MASK_MASK "pygame.mask.Mask\n\npygame object for representing 2D bitmasks\n\nMask(size=(width, height)) -> Mask\n\nMask(size=(width, height), fill=False) -> Mask\n\nA Mask object is used to represent a 2D bitmask. Each bit in\nthe mask represents a pixel. 1 is used to indicate a set bit and 0 is used\nto indicate an unset bit. Set bits in a mask can be used to detect collisions\nwith other masks and their set bits.\n\nA filled mask has all of its bits set to 1, conversely an\nunfilled/cleared/empty mask has all of its bits set to 0. Masks can be\ncreated unfilled (default) or filled by using the fill parameter. Masks\ncan also be cleared or filled using the pygame.mask.Mask.clear() and\npygame.mask.Mask.fill() methods respectively.\n\nA mask's coordinates start in the top left corner at (0, 0) just like\npygame.Surface. Individual bits can be accessed using the\npygame.mask.Mask.get_at() and pygame.mask.Mask.set_at()\nmethods.\n\n\n\nThe methods overlap(), overlap_area(), overlap_mask(),\ndraw(), erase(), and convolve() use an offset parameter\nto indicate the offset of another mask's top left corner from the calling\nmask's top left corner. The calling mask's top left corner is considered to\nbe the origin (0, 0). Offsets are a sequence of two values\n(x_offset, y_offset). Positive and negative offset values are supported.\n\n           0 to x (x_offset)\n           :    :\n   0 ..... +----:---------+\n   to      |    :         |\n   y .......... +-----------+\n(y_offset) |    | othermask |\n           |    +-----------+\n           | calling_mask |\n           +--------------+\n\nParameters\n\nsize -- the dimensions of the mask (width and height)\n\nfill (bool) -- (optional) create an unfilled mask (default: False) or\nfilled mask (True)\n\nReturns\n\na newly created Mask object\n\nReturn type\n\nMask\n\nChanged in pygame 2.0.0: Shallow copy support added. The Mask class supports the special\nmethod __copy__() and shallow copying via copy.copy(mask).\n\nChanged in pygame 2.0.0: Subclassing support added. The Mask class\ncan be used as a base class.\n\nChanged in pygame 1.9.5: Added support for keyword arguments.\n\nChanged in pygame 1.9.5: Added the optional keyword parameter fill.\n\nChanged in pygame 1.9.5: Added support for masks with a width and/or a\nheight of 0.\n\n"
#define DOC_MASK_MASK_COPY "copy()\n\nReturns a new copy of the mask\n\ncopy() -> Mask\n\nReturns\n\na new copy of this mask, the new mask will have the same width,\nheight, and set/unset bits as the original\n\nReturn type\n\nMask\n\nIf a mask subclass needs to copy any instance specific attributes\nthen it should override the __copy__() method. The overridden\n__copy__() method needs to call super().__copy__() and then\ncopy the required data as in the following example code.\n\nclass SubMask(pygame.mask.Mask):\n    def __copy__(self):\n        new_mask = super().__copy__()\n        # Do any SubMask attribute copying here.\n        return new_mask\n\nNew in pygame 2.0.0."
#define DOC_MASK_MASK_GETSIZE "get_size()\n\nReturns the size of the mask\n\nget_size() -> (width, height)\n\nReturns\n\nthe size of the mask, (width, height)\n\nReturn type\n\ntuple(int, int)"
#define DOC_MASK_MASK_GETRECT "get_rect()\n\nReturns a Rect based on the size of the mask\n\nget_rect(**kwargs) -> Rect\n\nReturns a new pygame.Rect() object based on the size of this mask.\nThe rect's default position will be (0, 0) and its default width and\nheight will be the same as this mask's. The rect's attributes can be\naltered via pygame.Rect() attribute keyword arguments/values passed\ninto this method. As an example, a_mask.get_rect(center=(10, 5)) would\ncreate a pygame.Rect() based on the mask's size centered at the\ngiven position.\n\nParameters\n\nkwargs (dict) -- pygame.Rect() attribute keyword arguments/values\nthat will be applied to the rect\n\nReturns\n\na new pygame.Rect() object based on the size of this mask\nwith any pygame.Rect() attribute keyword arguments/values applied\nto it\n\nReturn type\n\nRect\n\nNew in pygame 2.0.0."
#define DOC_MASK_MASK_GETAT "get_at()\n\nGets the bit at the given position\n\nget_at(pos) -> int\n\nParameters\n\npos -- the position of the bit to get (x, y)\n\nReturns\n\n1 if the bit is set, 0 if the bit is not set\n\nReturn type\n\nint\n\nRaises\n\nIndexError -- if the position is outside of the mask's bounds"
#define DOC_MASK_MASK_SETAT "set_at()\n\nSets the bit at the given position\n\nset_at(pos) -> None\n\nset_at(pos, value=1) -> None\n\nParameters\n\npos -- the position of the bit to set (x, y)\n\nvalue (int) -- any nonzero int will set the bit to 1, 0 will set the\nbit to 0 (default is 1)\n\nReturns\n\nNone\n\nReturn type\n\nNoneType\n\nRaises\n\nIndexError -- if the position is outside of the mask's bounds"
#define DOC_MASK_MASK_OVERLAP "overlap()\n\nReturns the point of intersection\n\noverlap(other, offset) -> (x, y)\n\noverlap(other, offset) -> None\n\nReturns the first point of intersection encountered between this mask and\nother. A point of intersection is 2 overlapping set bits.\n\nThe current algorithm searches the overlapping area in\nsizeof(unsigned long int) * CHAR_BIT bit wide column blocks (the value\nof sizeof(unsigned long int) * CHAR_BIT is platform dependent, for\nclarity it will be referred to as W). Starting at the top left corner\nit checks bits 0 to W - 1 of the first row ((0, 0) to\n(W - 1, 0)) then continues to the next row ((0, 1) to\n(W - 1, 1)). Once this entire column block is checked, it continues to\nthe next one (W to 2 * W - 1). This is repeated until it finds a\npoint of intersection or the entire overlapping area is checked.\n\nParameters\n\nother (Mask) -- the other mask to overlap with this mask\n\noffset -- the offset of other from this mask, for more\ndetails refer to the Mask offset notes\n\nReturns\n\npoint of intersection or None if no intersection\n\nReturn type\n\ntuple(int, int) or NoneType"
#define DOC_MASK_MASK_OVERLAPAREA "overlap_area()\n\nReturns the number of overlapping set bits\n\noverlap_area(other, offset) -> numbits\n\nReturns the number of overlapping set bits between between this mask and\nother.\n\nThis can be useful for collision detection. An approximate collision\nnormal can be found by calculating the gradient of the overlapping area\nthrough the finite difference.\n\ndx = mask.overlap_area(other, (x + 1, y)) - mask.overlap_area(other, (x - 1, y))\ndy = mask.overlap_area(other, (x, y + 1)) - mask.overlap_area(other, (x, y - 1))\n\nParameters\n\nother (Mask) -- the other mask to overlap with this mask\n\noffset -- the offset of other from this mask, for more\ndetails refer to the Mask offset notes\n\nReturns\n\nthe number of overlapping set bits\n\nReturn type\n\nint"
#define DOC_MASK_MASK_OVERLAPMASK "overlap_mask()\n\nReturns a mask of the overlapping set bits\n\noverlap_mask(other, offset) -> Mask\n\nReturns a Mask, the same size as this mask, containing the\noverlapping set bits between this mask and other.\n\nParameters\n\nother (Mask) -- the other mask to overlap with this mask\n\noffset -- the offset of other from this mask, for more\ndetails refer to the Mask offset notes\n\nReturns\n\na newly created Mask with the overlapping bits set\n\nReturn type\n\nMask"
#define DOC_MASK_MASK_FILL "fill()\n\nSets all bits to 1\n\nfill() -> None\n\nSets all bits in the mask to 1.\n\nReturns\n\nNone\n\nReturn type\n\nNoneType"
#define DOC_MASK_MASK_CLEAR "clear()\n\nSets all bits to 0\n\nclear() -> None\n\nSets all bits in the mask to 0.\n\nReturns\n\nNone\n\nReturn type\n\nNoneType"
#define DOC_MASK_MASK_INVERT "invert()\n\nFlips all the bits\n\ninvert() -> None\n\nFlips all of the bits in the mask. All the set bits are cleared to 0 and\nall the unset bits are set to 1.\n\nReturns\n\nNone\n\nReturn type\n\nNoneType"
#define DOC_MASK_MASK_SCALE "scale()\n\nResizes a mask\n\nscale((width, height)) -> Mask\n\nCreates a new Mask of the requested size with its bits scaled\nfrom this mask.\n\nParameters\n\nsize -- the width and height (size) of the mask to create\n\nReturns\n\na new Mask object with its bits scaled from this mask\n\nReturn type\n\nMask\n\nRaises\n\nValueError -- if width < 0 or height < 0"
#define DOC_MASK_MASK_DRAW "draw()\n\nDraws a mask onto another\n\ndraw(other, offset) -> None\n\nPerforms a bitwise OR, drawing othermask onto this mask.\n\nParameters\n\nother (Mask) -- the mask to draw onto this mask\n\noffset -- the offset of other from this mask, for more\ndetails refer to the Mask offset notes\n\nReturns\n\nNone\n\nReturn type\n\nNoneType"
#define DOC_MASK_MASK_ERASE "erase()\n\nErases a mask from another\n\nerase(other, offset) -> None\n\nErases (clears) all bits set in other from this mask.\n\nParameters\n\nother (Mask) -- the mask to erase from this mask\n\noffset -- the offset of other from this mask, for more\ndetails refer to the Mask offset notes\n\nReturns\n\nNone\n\nReturn type\n\nNoneType"
#define DOC_MASK_MASK_COUNT "count()\n\nReturns the number of set bits\n\ncount() -> bits\n\nReturns\n\nthe number of set bits in the mask\n\nReturn type\n\nint"
#define DOC_MASK_MASK_CENTROID "centroid()\n\nReturns the centroid of the set bits\n\ncentroid() -> (x, y)\n\nFinds the centroid (the center mass of the set bits) for this mask.\n\nReturns\n\na coordinate tuple indicating the centroid of the mask, it will\nreturn (0, 0) if the mask has no bits set\n\nReturn type\n\ntuple(int, int)"
#define DOC_MASK_MASK_ANGLE "angle()\n\nReturns the orientation of the set bits\n\nangle() -> theta\n\nFinds the approximate orientation (from -90 to 90 degrees) of the set bits\nin the mask. This works best if performed on a mask with only one\nconnected component.\n\nReturns\n\nthe orientation of the set bits in the mask, it will return\n0.0 if the mask has no bits set\n\nReturn type\n\nfloat\n\nSee connected_component() for details on how a connected\ncomponent is calculated."
#define DOC_MASK_MASK_OUTLINE "outline()\n\nReturns a list of points outlining an object\n\noutline() -> [(x, y), ...]\n\noutline(every=1) -> [(x, y), ...]\n\nReturns a list of points of the outline of the first connected component\nencountered in the mask. To find a connected component, the mask is\nsearched per row (left to right) starting in the top left corner.\n\nThe every optional parameter skips set bits in the outline. For\nexample, setting it to 10 would return a list of every 10th set bit in the\noutline.\n\nParameters\n\nevery (int) -- (optional) indicates the number of bits to skip over in\nthe outline (default is 1)\n\nReturns\n\na list of points outlining the first connected component\nencountered, an empty list is returned if the mask has no bits set\n\nReturn type\n\nlist[tuple(int, int)]\n\nSee connected_component() for details on how a connected\ncomponent is calculated."
#define DOC_MASK_MASK_CONVOLVE "convolve()\n\nReturns the convolution of this mask with another mask\n\nconvolve(other) -> Mask\n\nconvolve(other, output=None, offset=(0, 0)) -> Mask\n\nConvolve this mask with the given other Mask.\n\nParameters\n\nother (Mask) -- mask to convolve this mask with\n\noutput (Mask or NoneType) -- (optional) mask for output (default is None)\n\noffset -- the offset of other from this mask, (default is\n(0, 0))\n\nReturns\n\na Mask with the (i - offset[0], j - offset[1]) bit\nset, if shifting other (such that its bottom right corner is at\n(i, j)) causes it to overlap with this maskIf an output Mask is specified, the output is drawn onto it and\nit is returned. Otherwise a mask of size (MAX(0, width + other mask's\nwidth - 1), MAX(0, height + other mask's height - 1)) is created and\nreturned.\n\nReturn type\n\nMask"
#define DOC_MASK_MASK_CONNECTEDCOMPONENT "connected_component()\n\nReturns a mask containing a connected component\n\nconnected_component() -> Mask\n\nconnected_component(pos) -> Mask\n\nA connected component is a group (1 or more) of connected set bits\n(orthogonally and diagonally). The SAUF algorithm, which checks 8 point\nconnectivity, is used to find a connected component in the mask.\n\nBy default this method will return a Mask containing the largest\nconnected component in the mask. Optionally, a bit coordinate can be\nspecified and the connected component containing it will be returned. If\nthe bit at the given location is not set, the returned Mask will\nbe empty (no bits set).\n\nParameters\n\npos -- (optional) selects the connected component that contains the\nbit at this position\n\nReturns\n\na Mask object (same size as this mask) with the largest\nconnected component from this mask, if this mask has no bits set then\nan empty mask will be returnedIf the pos parameter is provided then the mask returned will have\nthe connected component that contains this position. An empty mask will\nbe returned if the pos parameter selects an unset bit.\n\nReturn type\n\nMask\n\nRaises\n\nIndexError -- if the optional pos parameter is outside of the\nmask's bounds"
#define DOC_MASK_MASK_CONNECTEDCOMPONENTS "connected_components()\n\nReturns a list of masks of connected components\n\nconnected_components() -> [Mask, ...]\n\nconnected_components(minimum=0) -> [Mask, ...]\n\nProvides a list containing a Mask object for each connected\ncomponent.\n\nParameters\n\nminimum (int) -- (optional) indicates the minimum number of bits (to\nfilter out noise) per connected component (default is 0, which equates\nto no minimum and is equivalent to setting it to 1, as a connected\ncomponent must have at least 1 bit set)\n\nReturns\n\na list containing a Mask object for each connected\ncomponent, an empty list is returned if the mask has no bits set\n\nReturn type\n\nlist[Mask]\n\nSee connected_component() for details on how a connected\ncomponent is calculated."
#define DOC_MASK_MASK_GETBOUNDINGRECTS "get_bounding_rects()\n\nReturns a list of bounding rects of connected components\n\nget_bounding_rects() -> [Rect, ...]\n\nProvides a list containing a bounding rect for each connected component.\n\nReturns\n\na list containing a bounding rect for each connected component,\nan empty list is returned if the mask has no bits set\n\nReturn type\n\nlist[Rect]\n\nSee connected_component() for details on how a connected\ncomponent is calculated."
#define DOC_MASK_MASK_TOSURFACE "to_surface()\n\nReturns a surface with the mask drawn on it\n\nto_surface() -> Surface\n\nto_surface(surface=None, setsurface=None, unsetsurface=None, setcolor=(255, 255, 255, 255), unsetcolor=(0, 0, 0, 255), dest=(0, 0)) -> Surface\n\nDraws this mask on the given surface. Set bits (bits set to 1) and unset\nbits (bits set to 0) can be drawn onto a surface.\n\nParameters\n\nsurface (Surface or None) -- (optional) Surface to draw mask onto, if no surface is\nprovided one will be created (default is None, which will cause a\nsurface with the parameters\nSurface(size=mask.get_size(), flags=SRCALPHA, depth=32) to be\ncreated, drawn on, and returned)\n\nsetsurface (Surface or None) -- (optional) use this surface's color values to draw\nset bits (default is None), if this surface is smaller than the\nmask any bits outside its bounds will use the setcolor value\n\nunsetsurface (Surface or None) -- (optional) use this surface's color values to draw\nunset bits (default is None), if this surface is smaller than the\nmask any bits outside its bounds will use the unsetcolor value\n\nsetcolor (pygame.typing.ColorLike or None) -- (optional) color to draw set bits (default is\n(255, 255, 255, 255), white), use None to skip drawing the set\nbits, the setsurface parameter (if set) will takes precedence over\nthis parameter\n\nunsetcolor (pygame.typing.ColorLike or None) -- (optional) color to draw unset bits (default is\n(0, 0, 0, 255), black), use None to skip drawing the unset\nbits, the unsetsurface parameter (if set) will takes precedence\nover this parameter\n\ndest (Rect or tuple(int, int) or list(int, int) or Vector2(int, int)) -- (optional) surface destination of where to position the\ntopleft corner of the mask being drawn (default is (0, 0)), if a\nRect is used as the dest parameter, its x and y attributes\nwill be used as the destination, NOTE1: rects with a negative width\nor height value will not be normalized before using their x and\ny values, NOTE2: this destination value is only used to\nposition the mask on the surface, it does not offset the setsurface\nand unsetsurface from the mask, they are always aligned with the\nmask (i.e. position (0, 0) on the mask always corresponds to\nposition (0, 0) on the setsurface and unsetsurface)\n\nReturns\n\nthe surface parameter (or a newly created surface if no\nsurface parameter was provided) with this mask drawn on it\n\nReturn type\n\nSurface\n\nRaises\n\nValueError -- if the setsurface parameter or unsetsurface\nparameter does not have the same format (bytesize/bitsize/alpha) as\nthe surface parameter\n\nTo skip drawing the set bits, both setsurface and setcolor must\nbe None. The setsurface parameter defaults to None, but\nsetcolor defaults to a color value and therefore must be set to\nNone.\n\nTo skip drawing the unset bits, both unsetsurface and\nunsetcolor must be None. The unsetsurface parameter\ndefaults to None, but unsetcolor defaults to a color value and\ntherefore must be set to None.\n\nNew in pygame 2.0.0."
