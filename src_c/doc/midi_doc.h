/* Auto generated file: with make_docs.py .  Docs go in docs/reST/ref/ . */
#define DOC_MIDI "pygame.midi\n\n\n\npygame module for interacting with midi input and output.\n\nNew in pygame 1.9.0.\n\nThe midi module can send output to midi devices and get input from midi\ndevices. It can also list midi devices on the system.\n\nThe midi module supports real and virtual midi devices.\n\nIt uses the portmidi library. Is portable to which ever platforms portmidi\nsupports (currently Windows, Mac OS X, and Linux).\n\nThis uses pyportmidi for now, but may use its own bindings at some point in the\nfuture. The pyportmidi bindings are included with pygame.\n\n\n\nNew in pygame 2.0.0.\n\nThese are pygame events (pygame.event) reserved for midi use. The\nMIDIIN event is used by pygame.midi.midis2events() when converting\nmidi events to pygame events.\n\nMIDIIN\nMIDIOUT"
#define DOC_MIDI_INIT "pygame.midi.init()\n\ninitialize the midi module\n\ninit() -> None\n\nInitializes the pygame.midi module. Must be called before using the\npygame.midi module.\n\nIt is safe to call this more than once."
#define DOC_MIDI_QUIT "pygame.midi.quit()\n\nuninitialize the midi module\n\nquit() -> None\n\nUninitializes the pygame.midi module. If pygame.midi.init() was\ncalled to initialize the pygame.midi module, then this function will\nbe called automatically when your program exits.\n\nIt is safe to call this function more than once."
#define DOC_MIDI_GETINIT "pygame.midi.get_init()\n\nreturns True if the midi module is currently initialized\n\nget_init() -> bool\n\nGets the initialization state of the pygame.midi module.\n\nReturns\n\nTrue if the pygame.midi module is currently initialized.\n\nReturn type\n\nbool\n\nNew in pygame 1.9.5."
#define DOC_MIDI_INPUT "pygame.midi.Input\n\nInput is used to get midi input from midi devices.\n\nInput(device_id) -> None\n\nInput(device_id, buffer_size) -> None\n\nParameters\n\ndevice_id (int) -- midi device id\n\nbuffer_size (int) -- (optional) the number of input events to be buffered\n\n"
#define DOC_MIDI_INPUT_CLOSE "close()\n\ncloses a midi stream, flushing any pending buffers.\n\nclose() -> None\n\nPortMidi attempts to close open streams when the application exits.\n\nThis is particularly difficult under Windows."
#define DOC_MIDI_INPUT_POLL "poll()\n\nreturns True if there's data, or False if not.\n\npoll() -> bool\n\nUsed to indicate if any data exists.\n\nReturns\n\nTrue if there is data, False otherwise\n\nReturn type\n\nbool\n\nRaises\n\nMidiException -- on error"
#define DOC_MIDI_INPUT_READ "read()\n\nreads num_events midi events from the buffer.\n\nread(num_events) -> midi_event_list\n\nReads from the input buffer and gives back midi events.\n\nParameters\n\nnum_events (int) -- number of input events to read\n\nReturns\n\nthe format for midi_event_list is\n[[[status, data1, data2, data3], timestamp], ...]\n\nReturn type\n\nlist"
#define DOC_MIDI_OUTPUT "pygame.midi.Output\n\nOutput is used to send midi to an output device\n\nOutput(device_id) -> None\n\nOutput(device_id, latency=0) -> None\n\nOutput(device_id, buffer_size=256) -> None\n\nOutput(device_id, latency, buffer_size) -> None\n\nThe buffer_size specifies the number of output events to be buffered\nwaiting for output. In some cases (see below) PortMidi does not buffer\noutput at all and merely passes data to a lower-level API, in which case\nbuffersize is ignored.\n\nlatency is the delay in milliseconds applied to timestamps to determine\nwhen the output should actually occur. If latency is <<0, 0 is assumed.\n\nIf latency is zero, timestamps are ignored and all output is delivered\nimmediately. If latency is greater than zero, output is delayed until the\nmessage timestamp plus the latency. In some cases, PortMidi can obtain\nbetter timing than your application by passing timestamps along to the\ndevice driver or hardware. Latency may also help you to synchronize midi\ndata to audio data by matching midi latency to the audio buffer latency.\n\nTime is measured relative to the time source indicated by time_proc.\nTimestamps are absolute, not relative delays or offsets.\n\n"
#define DOC_MIDI_OUTPUT_ABORT "abort()\n\nterminates outgoing messages immediately\n\nabort() -> None\n\nThe caller should immediately close the output port; this call may result\nin transmission of a partial midi message. There is no abort for Midi\ninput because the user can simply ignore messages in the buffer and close\nan input device at any time."
#define DOC_MIDI_OUTPUT_CLOSE "close()\n\ncloses a midi stream, flushing any pending buffers.\n\nclose() -> None\n\nPortMidi attempts to close open streams when the application exits.\n\nThis is particularly difficult under Windows."
#define DOC_MIDI_OUTPUT_NOTEOFF "note_off()\n\nturns a midi note off (note must be on)\n\nnote_off(note, velocity=None, channel=0) -> None\n\nTurn a note off in the output stream. The note must already be on for\nthis to work correctly."
#define DOC_MIDI_OUTPUT_NOTEON "note_on()\n\nturns a midi note on (note must be off)\n\nnote_on(note, velocity=None, channel=0) -> None\n\nTurn a note on in the output stream. The note must already be off for\nthis to work correctly."
#define DOC_MIDI_OUTPUT_SETINSTRUMENT "set_instrument()\n\nselect an instrument, with a value between 0 and 127\n\nset_instrument(instrument_id, channel=0) -> None\n\nSelect an instrument."
#define DOC_MIDI_OUTPUT_PITCHBEND "pitch_bend()\n\nmodify the pitch of a channel.\n\nset_instrument(value=0, channel=0) -> None\n\nAdjust the pitch of a channel. The value is a signed integer\nfrom -8192 to +8191. For example, 0 means \"no change\", +4096 is\ntypically a semitone higher, and -8192 is 1 whole tone lower (though\nthe musical range corresponding to the pitch bend range can also be\nchanged in some synthesizers).\n\nIf no value is given, the pitch bend is returned to \"no change\".\n\nNew in pygame 1.9.4."
#define DOC_MIDI_OUTPUT_WRITE "write()\n\nwrites a list of midi data to the Output\n\nwrite(data) -> None\n\nWrites series of MIDI information in the form of a list.\n\nParameters\n\ndata (list) -- data to write, the expected format is\n[[[status, data1=0, data2=0, ...], timestamp], ...]\nwith the data# fields being optional\n\nRaises\n\nIndexError -- if more than 1024 elements in the data list\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:237: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nExample:\n\n# Program change at time 20000 and 500ms later send note 65 with\n# velocity 100.\nwrite([[[0xc0, 0, 0], 20000], [[0x90, 60, 100], 20500]])\n\nTimestamps will be ignored if latency = 0\n\nTo get a note to play immediately, send MIDI info with timestamp\nread from function Time\n\nOptional data fields: write([[[0xc0, 0, 0], 20000]]) is\nequivalent to write([[[0xc0], 20000]])"
#define DOC_MIDI_OUTPUT_WRITESHORT "write_short()\n\nwrites up to 3 bytes of midi data to the Output\n\nwrite_short(status) -> None\n\nwrite_short(status, data1=0, data2=0) -> None\n\nOutput MIDI information of 3 bytes or less. The data fields are\noptional and assumed to be 0 if omitted.\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:262: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nExamples of status byte values:\n\n0xc0  # program change\n0x90  # note on\n# etc.\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:269: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nExample:\n\n# note 65 on with velocity 100\nwrite_short(0x90, 65, 100)"
#define DOC_MIDI_OUTPUT_WRITESYSEX "write_sys_ex()\n\nwrites a timestamped system-exclusive midi message.\n\nwrite_sys_ex(when, msg) -> None\n\nWrites a timestamped system-exclusive midi message.\n\nParameters\n\nmsg (list[int] or str) -- midi message\n\nwhen -- timestamp in milliseconds\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:288: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nExample:\n\nmidi_output.write_sys_ex(0, '\\xF0\\x7D\\x10\\x11\\x12\\x13\\xF7')\n\n# is equivalent to\n\nmidi_output.write_sys_ex(pygame.midi.time(),\n                         [0xF0, 0x7D, 0x10, 0x11, 0x12, 0x13, 0xF7])"
#define DOC_MIDI_GETCOUNT "pygame.midi.get_count()\n\ngets the number of devices.\n\nget_count() -> num_devices\n\nDevice ids range from 0 to get_count() - 1"
#define DOC_MIDI_GETDEFAULTINPUTID "pygame.midi.get_default_input_id()\n\ngets default input device number\n\nget_default_input_id() -> default_id\n\nThe following describes the usage details for this function and the\nget_default_output_id() function.\n\nReturn the default device ID or -1 if there are no devices. The result\ncan be passed to the Input/Output class.\n\nOn a PC the user can specify a default device by setting an environment\nvariable. To use device #1, for example:\n\nset PM_RECOMMENDED_INPUT_DEVICE=1\nor\nset PM_RECOMMENDED_OUTPUT_DEVICE=1\n\nThe user should first determine the available device ID by using the\nsupplied application \"testin\" or \"testout\".\n\nIn general, the registry is a better place for this kind of info. With\nUSB devices that can come and go, using integers is not very reliable\nfor device identification. Under Windows, if PM_RECOMMENDED_INPUT_DEVICE\n(or PM_RECOMMENDED_OUTPUT_DEVICE) is NOT found in the environment,\nthen the default device is obtained by looking for a string in the registry\nunder:\n\nHKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Input_Device\nor\nHKEY_LOCAL_MACHINE/SOFTWARE/PortMidi/Recommended_Output_Device\n\nThe number of the first device with a substring that matches the\nstring exactly is returned. For example, if the string in the registry is\n\"USB\" and device 1 is named \"In USB MidiSport 1x1\", then that will be\nthe default input because it contains the string \"USB\".\n\nIn addition to the name, get_device_info() returns \"interf\", which is\nthe interface name. The \"interface\" is the underlying software system or\nAPI used by PortMidi to access devices. Supported interfaces:\n\nMMSystem   # the only Win32 interface currently supported\nALSA       # the only Linux interface currently supported\nCoreMIDI   # the only Mac OS X interface currently supported\n# DirectX - not implemented\n# OSS     - not implemented\n\nTo specify both the interface and the device name in the registry, separate\nthe two with a comma and a space. The string before the comma must be a\nsubstring of the \"interf\" string and the string after the space must be a\nsubstring of the \"name\" name string in order to match the device. e.g.:\n\nMMSystem, In USB MidiSport 1x1\n\nIn the current release, the default is simply the first device (the\ninput or output device with the lowest PmDeviceID)."
#define DOC_MIDI_GETDEFAULTOUTPUTID "pygame.midi.get_default_output_id()\n\ngets default output device number\n\nget_default_output_id() -> default_id\n\nSee get_default_input_id() for usage details."
#define DOC_MIDI_GETDEVICEINFO "pygame.midi.get_device_info()\n\nreturns information about a midi device\n\nget_device_info(an_id) -> (interf, name, input, output, opened)\n\nget_device_info(an_id) -> None\n\nGets the device info for a given id.\n\nParameters\n\nan_id (int) -- id of the midi device being queried\n\nReturns\n\nif the id is out of range None is returned, otherwise\na tuple of (interf, name, input, output, opened) is returned.interf: string describing the device interface (e.g. 'ALSA')\n\nname: string name of the device (e.g. 'Midi Through Port-0')\n\ninput: 1 if the device is an input device, otherwise 0\n\noutput: 1 if the device is an output device, otherwise 0\n\nopened: 1 if the device is opened, otherwise 0\n\nReturn type\n\ntuple or None"
#define DOC_MIDI_MIDIS2EVENTS "pygame.midi.midis2events()\n\nconverts midi events to pygame events\n\nmidis2events(midi_events, device_id) -> [Event, ...]\n\nTakes a sequence of midi events and returns list of pygame events.\n\nThe midi_events data is expected to be a sequence of\n((status, data1, data2, data3), timestamp) midi events (all values\nrequired).\n\nReturns\n\na list of pygame events of event type MIDIIN\n\nReturn type\n\nlist"
#define DOC_MIDI_TIME "pygame.midi.time()\n\nreturns the current time in ms of the PortMidi timer\n\ntime() -> time\n\nThe time is reset to 0 when the pygame.midi module is initialized."
#define DOC_MIDI_FREQUENCYTOMIDI "pygame.midi.frequency_to_midi()\n\nConverts a frequency into a MIDI note. Rounds to the closest midi note.\n\nfrequency_to_midi(midi_note) -> midi_note\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:438: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nexample:\n\nfrequency_to_midi(27.5) == 21\n\nNew in pygame 1.9.5."
#define DOC_MIDI_MIDITOFREQUENCY "pygame.midi.midi_to_frequency()\n\nConverts a midi note to a frequency.\n\nmidi_to_frequency(midi_note) -> frequency\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:453: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nexample:\n\nmidi_to_frequency(21) == 27.5\n\nNew in pygame 1.9.5."
#define DOC_MIDI_MIDITOANSINOTE "pygame.midi.midi_to_ansi_note()\n\nReturns the Ansi Note name for a midi number.\n\nmidi_to_ansi_note(midi_note) -> ansi_note\n\nD:\\Adatok\\User\\Documents\\Programming\\Python\\Pygame\\pygame-ce\\docs\\reST\\ref/midi.rst:468: (INFO/1) Possible title underline, too short for the title.\nTreating it as ordinary text because it's so short.\n\nexample:\n\nmidi_to_ansi_note(21) == 'A0'\n\nNew in pygame 1.9.5."
#define DOC_MIDI_MIDIEXCEPTION "exception pygame.midi.MidiException\n\nexception that pygame.midi functions and classes can raise\n\nMidiException(errno) -> None"
